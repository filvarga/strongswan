// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vpp/model/acl/acl.proto

#ifndef PROTOBUF_INCLUDED_vpp_2fmodel_2facl_2facl_2eproto
#define PROTOBUF_INCLUDED_vpp_2fmodel_2facl_2facl_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_vpp_2fmodel_2facl_2facl_2eproto 

namespace protobuf_vpp_2fmodel_2facl_2facl_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_vpp_2fmodel_2facl_2facl_2eproto
namespace acl {
class AccessLists;
class AccessListsDefaultTypeInternal;
extern AccessListsDefaultTypeInternal _AccessLists_default_instance_;
class AccessLists_Acl;
class AccessLists_AclDefaultTypeInternal;
extern AccessLists_AclDefaultTypeInternal _AccessLists_Acl_default_instance_;
class AccessLists_Acl_Interfaces;
class AccessLists_Acl_InterfacesDefaultTypeInternal;
extern AccessLists_Acl_InterfacesDefaultTypeInternal _AccessLists_Acl_Interfaces_default_instance_;
class AccessLists_Acl_Rule;
class AccessLists_Acl_RuleDefaultTypeInternal;
extern AccessLists_Acl_RuleDefaultTypeInternal _AccessLists_Acl_Rule_default_instance_;
class AccessLists_Acl_Rule_Match;
class AccessLists_Acl_Rule_MatchDefaultTypeInternal;
extern AccessLists_Acl_Rule_MatchDefaultTypeInternal _AccessLists_Acl_Rule_Match_default_instance_;
class AccessLists_Acl_Rule_Match_IpRule;
class AccessLists_Acl_Rule_Match_IpRuleDefaultTypeInternal;
extern AccessLists_Acl_Rule_Match_IpRuleDefaultTypeInternal _AccessLists_Acl_Rule_Match_IpRule_default_instance_;
class AccessLists_Acl_Rule_Match_IpRule_Icmp;
class AccessLists_Acl_Rule_Match_IpRule_IcmpDefaultTypeInternal;
extern AccessLists_Acl_Rule_Match_IpRule_IcmpDefaultTypeInternal _AccessLists_Acl_Rule_Match_IpRule_Icmp_default_instance_;
class AccessLists_Acl_Rule_Match_IpRule_Icmp_Range;
class AccessLists_Acl_Rule_Match_IpRule_Icmp_RangeDefaultTypeInternal;
extern AccessLists_Acl_Rule_Match_IpRule_Icmp_RangeDefaultTypeInternal _AccessLists_Acl_Rule_Match_IpRule_Icmp_Range_default_instance_;
class AccessLists_Acl_Rule_Match_IpRule_Ip;
class AccessLists_Acl_Rule_Match_IpRule_IpDefaultTypeInternal;
extern AccessLists_Acl_Rule_Match_IpRule_IpDefaultTypeInternal _AccessLists_Acl_Rule_Match_IpRule_Ip_default_instance_;
class AccessLists_Acl_Rule_Match_IpRule_PortRange;
class AccessLists_Acl_Rule_Match_IpRule_PortRangeDefaultTypeInternal;
extern AccessLists_Acl_Rule_Match_IpRule_PortRangeDefaultTypeInternal _AccessLists_Acl_Rule_Match_IpRule_PortRange_default_instance_;
class AccessLists_Acl_Rule_Match_IpRule_Tcp;
class AccessLists_Acl_Rule_Match_IpRule_TcpDefaultTypeInternal;
extern AccessLists_Acl_Rule_Match_IpRule_TcpDefaultTypeInternal _AccessLists_Acl_Rule_Match_IpRule_Tcp_default_instance_;
class AccessLists_Acl_Rule_Match_IpRule_Udp;
class AccessLists_Acl_Rule_Match_IpRule_UdpDefaultTypeInternal;
extern AccessLists_Acl_Rule_Match_IpRule_UdpDefaultTypeInternal _AccessLists_Acl_Rule_Match_IpRule_Udp_default_instance_;
class AccessLists_Acl_Rule_Match_MacIpRule;
class AccessLists_Acl_Rule_Match_MacIpRuleDefaultTypeInternal;
extern AccessLists_Acl_Rule_Match_MacIpRuleDefaultTypeInternal _AccessLists_Acl_Rule_Match_MacIpRule_default_instance_;
}  // namespace acl
namespace google {
namespace protobuf {
template<> ::acl::AccessLists* Arena::CreateMaybeMessage<::acl::AccessLists>(Arena*);
template<> ::acl::AccessLists_Acl* Arena::CreateMaybeMessage<::acl::AccessLists_Acl>(Arena*);
template<> ::acl::AccessLists_Acl_Interfaces* Arena::CreateMaybeMessage<::acl::AccessLists_Acl_Interfaces>(Arena*);
template<> ::acl::AccessLists_Acl_Rule* Arena::CreateMaybeMessage<::acl::AccessLists_Acl_Rule>(Arena*);
template<> ::acl::AccessLists_Acl_Rule_Match* Arena::CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match>(Arena*);
template<> ::acl::AccessLists_Acl_Rule_Match_IpRule* Arena::CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule>(Arena*);
template<> ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp* Arena::CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp>(Arena*);
template<> ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* Arena::CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range>(Arena*);
template<> ::acl::AccessLists_Acl_Rule_Match_IpRule_Ip* Arena::CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_Ip>(Arena*);
template<> ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* Arena::CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange>(Arena*);
template<> ::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp* Arena::CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp>(Arena*);
template<> ::acl::AccessLists_Acl_Rule_Match_IpRule_Udp* Arena::CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_Udp>(Arena*);
template<> ::acl::AccessLists_Acl_Rule_Match_MacIpRule* Arena::CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_MacIpRule>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace acl {

enum AclAction {
  DENY = 0,
  PERMIT = 1,
  REFLECT = 2,
  AclAction_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AclAction_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AclAction_IsValid(int value);
const AclAction AclAction_MIN = DENY;
const AclAction AclAction_MAX = REFLECT;
const int AclAction_ARRAYSIZE = AclAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* AclAction_descriptor();
inline const ::std::string& AclAction_Name(AclAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    AclAction_descriptor(), value);
}
inline bool AclAction_Parse(
    const ::std::string& name, AclAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AclAction>(
    AclAction_descriptor(), name, value);
}
// ===================================================================

class AccessLists_Acl_Rule_Match_IpRule_Ip : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acl.AccessLists.Acl.Rule.Match.IpRule.Ip) */ {
 public:
  AccessLists_Acl_Rule_Match_IpRule_Ip();
  virtual ~AccessLists_Acl_Rule_Match_IpRule_Ip();

  AccessLists_Acl_Rule_Match_IpRule_Ip(const AccessLists_Acl_Rule_Match_IpRule_Ip& from);

  inline AccessLists_Acl_Rule_Match_IpRule_Ip& operator=(const AccessLists_Acl_Rule_Match_IpRule_Ip& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLists_Acl_Rule_Match_IpRule_Ip(AccessLists_Acl_Rule_Match_IpRule_Ip&& from) noexcept
    : AccessLists_Acl_Rule_Match_IpRule_Ip() {
    *this = ::std::move(from);
  }

  inline AccessLists_Acl_Rule_Match_IpRule_Ip& operator=(AccessLists_Acl_Rule_Match_IpRule_Ip&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLists_Acl_Rule_Match_IpRule_Ip& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLists_Acl_Rule_Match_IpRule_Ip* internal_default_instance() {
    return reinterpret_cast<const AccessLists_Acl_Rule_Match_IpRule_Ip*>(
               &_AccessLists_Acl_Rule_Match_IpRule_Ip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AccessLists_Acl_Rule_Match_IpRule_Ip* other);
  friend void swap(AccessLists_Acl_Rule_Match_IpRule_Ip& a, AccessLists_Acl_Rule_Match_IpRule_Ip& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLists_Acl_Rule_Match_IpRule_Ip* New() const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule_Ip>(NULL);
  }

  AccessLists_Acl_Rule_Match_IpRule_Ip* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule_Ip>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLists_Acl_Rule_Match_IpRule_Ip& from);
  void MergeFrom(const AccessLists_Acl_Rule_Match_IpRule_Ip& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLists_Acl_Rule_Match_IpRule_Ip* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string destination_network = 1;
  void clear_destination_network();
  static const int kDestinationNetworkFieldNumber = 1;
  const ::std::string& destination_network() const;
  void set_destination_network(const ::std::string& value);
  #if LANG_CXX11
  void set_destination_network(::std::string&& value);
  #endif
  void set_destination_network(const char* value);
  void set_destination_network(const char* value, size_t size);
  ::std::string* mutable_destination_network();
  ::std::string* release_destination_network();
  void set_allocated_destination_network(::std::string* destination_network);

  // string source_network = 2;
  void clear_source_network();
  static const int kSourceNetworkFieldNumber = 2;
  const ::std::string& source_network() const;
  void set_source_network(const ::std::string& value);
  #if LANG_CXX11
  void set_source_network(::std::string&& value);
  #endif
  void set_source_network(const char* value);
  void set_source_network(const char* value, size_t size);
  ::std::string* mutable_source_network();
  ::std::string* release_source_network();
  void set_allocated_source_network(::std::string* source_network);

  // @@protoc_insertion_point(class_scope:acl.AccessLists.Acl.Rule.Match.IpRule.Ip)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr destination_network_;
  ::google::protobuf::internal::ArenaStringPtr source_network_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2facl_2facl_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessLists_Acl_Rule_Match_IpRule_Icmp_Range : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.Range) */ {
 public:
  AccessLists_Acl_Rule_Match_IpRule_Icmp_Range();
  virtual ~AccessLists_Acl_Rule_Match_IpRule_Icmp_Range();

  AccessLists_Acl_Rule_Match_IpRule_Icmp_Range(const AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& from);

  inline AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& operator=(const AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLists_Acl_Rule_Match_IpRule_Icmp_Range(AccessLists_Acl_Rule_Match_IpRule_Icmp_Range&& from) noexcept
    : AccessLists_Acl_Rule_Match_IpRule_Icmp_Range() {
    *this = ::std::move(from);
  }

  inline AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& operator=(AccessLists_Acl_Rule_Match_IpRule_Icmp_Range&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* internal_default_instance() {
    return reinterpret_cast<const AccessLists_Acl_Rule_Match_IpRule_Icmp_Range*>(
               &_AccessLists_Acl_Rule_Match_IpRule_Icmp_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* other);
  friend void swap(AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& a, AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* New() const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule_Icmp_Range>(NULL);
  }

  AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule_Icmp_Range>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& from);
  void MergeFrom(const AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 first = 1;
  void clear_first();
  static const int kFirstFieldNumber = 1;
  ::google::protobuf::uint32 first() const;
  void set_first(::google::protobuf::uint32 value);

  // uint32 last = 2;
  void clear_last();
  static const int kLastFieldNumber = 2;
  ::google::protobuf::uint32 last() const;
  void set_last(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.Range)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 first_;
  ::google::protobuf::uint32 last_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2facl_2facl_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessLists_Acl_Rule_Match_IpRule_Icmp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp) */ {
 public:
  AccessLists_Acl_Rule_Match_IpRule_Icmp();
  virtual ~AccessLists_Acl_Rule_Match_IpRule_Icmp();

  AccessLists_Acl_Rule_Match_IpRule_Icmp(const AccessLists_Acl_Rule_Match_IpRule_Icmp& from);

  inline AccessLists_Acl_Rule_Match_IpRule_Icmp& operator=(const AccessLists_Acl_Rule_Match_IpRule_Icmp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLists_Acl_Rule_Match_IpRule_Icmp(AccessLists_Acl_Rule_Match_IpRule_Icmp&& from) noexcept
    : AccessLists_Acl_Rule_Match_IpRule_Icmp() {
    *this = ::std::move(from);
  }

  inline AccessLists_Acl_Rule_Match_IpRule_Icmp& operator=(AccessLists_Acl_Rule_Match_IpRule_Icmp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLists_Acl_Rule_Match_IpRule_Icmp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLists_Acl_Rule_Match_IpRule_Icmp* internal_default_instance() {
    return reinterpret_cast<const AccessLists_Acl_Rule_Match_IpRule_Icmp*>(
               &_AccessLists_Acl_Rule_Match_IpRule_Icmp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AccessLists_Acl_Rule_Match_IpRule_Icmp* other);
  friend void swap(AccessLists_Acl_Rule_Match_IpRule_Icmp& a, AccessLists_Acl_Rule_Match_IpRule_Icmp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLists_Acl_Rule_Match_IpRule_Icmp* New() const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule_Icmp>(NULL);
  }

  AccessLists_Acl_Rule_Match_IpRule_Icmp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule_Icmp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLists_Acl_Rule_Match_IpRule_Icmp& from);
  void MergeFrom(const AccessLists_Acl_Rule_Match_IpRule_Icmp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLists_Acl_Rule_Match_IpRule_Icmp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AccessLists_Acl_Rule_Match_IpRule_Icmp_Range Range;

  // accessors -------------------------------------------------------

  // .acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.Range icmp_code_range = 2;
  bool has_icmp_code_range() const;
  void clear_icmp_code_range();
  static const int kIcmpCodeRangeFieldNumber = 2;
  private:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& _internal_icmp_code_range() const;
  public:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& icmp_code_range() const;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* release_icmp_code_range();
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* mutable_icmp_code_range();
  void set_allocated_icmp_code_range(::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* icmp_code_range);

  // .acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.Range icmp_type_range = 3;
  bool has_icmp_type_range() const;
  void clear_icmp_type_range();
  static const int kIcmpTypeRangeFieldNumber = 3;
  private:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& _internal_icmp_type_range() const;
  public:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& icmp_type_range() const;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* release_icmp_type_range();
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* mutable_icmp_type_range();
  void set_allocated_icmp_type_range(::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* icmp_type_range);

  // bool icmpv6 = 1;
  void clear_icmpv6();
  static const int kIcmpv6FieldNumber = 1;
  bool icmpv6() const;
  void set_icmpv6(bool value);

  // @@protoc_insertion_point(class_scope:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* icmp_code_range_;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* icmp_type_range_;
  bool icmpv6_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2facl_2facl_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessLists_Acl_Rule_Match_IpRule_PortRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acl.AccessLists.Acl.Rule.Match.IpRule.PortRange) */ {
 public:
  AccessLists_Acl_Rule_Match_IpRule_PortRange();
  virtual ~AccessLists_Acl_Rule_Match_IpRule_PortRange();

  AccessLists_Acl_Rule_Match_IpRule_PortRange(const AccessLists_Acl_Rule_Match_IpRule_PortRange& from);

  inline AccessLists_Acl_Rule_Match_IpRule_PortRange& operator=(const AccessLists_Acl_Rule_Match_IpRule_PortRange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLists_Acl_Rule_Match_IpRule_PortRange(AccessLists_Acl_Rule_Match_IpRule_PortRange&& from) noexcept
    : AccessLists_Acl_Rule_Match_IpRule_PortRange() {
    *this = ::std::move(from);
  }

  inline AccessLists_Acl_Rule_Match_IpRule_PortRange& operator=(AccessLists_Acl_Rule_Match_IpRule_PortRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLists_Acl_Rule_Match_IpRule_PortRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLists_Acl_Rule_Match_IpRule_PortRange* internal_default_instance() {
    return reinterpret_cast<const AccessLists_Acl_Rule_Match_IpRule_PortRange*>(
               &_AccessLists_Acl_Rule_Match_IpRule_PortRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AccessLists_Acl_Rule_Match_IpRule_PortRange* other);
  friend void swap(AccessLists_Acl_Rule_Match_IpRule_PortRange& a, AccessLists_Acl_Rule_Match_IpRule_PortRange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLists_Acl_Rule_Match_IpRule_PortRange* New() const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule_PortRange>(NULL);
  }

  AccessLists_Acl_Rule_Match_IpRule_PortRange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule_PortRange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLists_Acl_Rule_Match_IpRule_PortRange& from);
  void MergeFrom(const AccessLists_Acl_Rule_Match_IpRule_PortRange& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLists_Acl_Rule_Match_IpRule_PortRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 lower_port = 1;
  void clear_lower_port();
  static const int kLowerPortFieldNumber = 1;
  ::google::protobuf::uint32 lower_port() const;
  void set_lower_port(::google::protobuf::uint32 value);

  // uint32 upper_port = 2;
  void clear_upper_port();
  static const int kUpperPortFieldNumber = 2;
  ::google::protobuf::uint32 upper_port() const;
  void set_upper_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:acl.AccessLists.Acl.Rule.Match.IpRule.PortRange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 lower_port_;
  ::google::protobuf::uint32 upper_port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2facl_2facl_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessLists_Acl_Rule_Match_IpRule_Tcp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp) */ {
 public:
  AccessLists_Acl_Rule_Match_IpRule_Tcp();
  virtual ~AccessLists_Acl_Rule_Match_IpRule_Tcp();

  AccessLists_Acl_Rule_Match_IpRule_Tcp(const AccessLists_Acl_Rule_Match_IpRule_Tcp& from);

  inline AccessLists_Acl_Rule_Match_IpRule_Tcp& operator=(const AccessLists_Acl_Rule_Match_IpRule_Tcp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLists_Acl_Rule_Match_IpRule_Tcp(AccessLists_Acl_Rule_Match_IpRule_Tcp&& from) noexcept
    : AccessLists_Acl_Rule_Match_IpRule_Tcp() {
    *this = ::std::move(from);
  }

  inline AccessLists_Acl_Rule_Match_IpRule_Tcp& operator=(AccessLists_Acl_Rule_Match_IpRule_Tcp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLists_Acl_Rule_Match_IpRule_Tcp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLists_Acl_Rule_Match_IpRule_Tcp* internal_default_instance() {
    return reinterpret_cast<const AccessLists_Acl_Rule_Match_IpRule_Tcp*>(
               &_AccessLists_Acl_Rule_Match_IpRule_Tcp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(AccessLists_Acl_Rule_Match_IpRule_Tcp* other);
  friend void swap(AccessLists_Acl_Rule_Match_IpRule_Tcp& a, AccessLists_Acl_Rule_Match_IpRule_Tcp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLists_Acl_Rule_Match_IpRule_Tcp* New() const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule_Tcp>(NULL);
  }

  AccessLists_Acl_Rule_Match_IpRule_Tcp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule_Tcp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLists_Acl_Rule_Match_IpRule_Tcp& from);
  void MergeFrom(const AccessLists_Acl_Rule_Match_IpRule_Tcp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLists_Acl_Rule_Match_IpRule_Tcp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .acl.AccessLists.Acl.Rule.Match.IpRule.PortRange destination_port_range = 1;
  bool has_destination_port_range() const;
  void clear_destination_port_range();
  static const int kDestinationPortRangeFieldNumber = 1;
  private:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& _internal_destination_port_range() const;
  public:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& destination_port_range() const;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* release_destination_port_range();
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* mutable_destination_port_range();
  void set_allocated_destination_port_range(::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* destination_port_range);

  // .acl.AccessLists.Acl.Rule.Match.IpRule.PortRange source_port_range = 2;
  bool has_source_port_range() const;
  void clear_source_port_range();
  static const int kSourcePortRangeFieldNumber = 2;
  private:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& _internal_source_port_range() const;
  public:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& source_port_range() const;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* release_source_port_range();
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* mutable_source_port_range();
  void set_allocated_source_port_range(::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* source_port_range);

  // uint32 tcp_flags_mask = 3;
  void clear_tcp_flags_mask();
  static const int kTcpFlagsMaskFieldNumber = 3;
  ::google::protobuf::uint32 tcp_flags_mask() const;
  void set_tcp_flags_mask(::google::protobuf::uint32 value);

  // uint32 tcp_flags_value = 4;
  void clear_tcp_flags_value();
  static const int kTcpFlagsValueFieldNumber = 4;
  ::google::protobuf::uint32 tcp_flags_value() const;
  void set_tcp_flags_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* destination_port_range_;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* source_port_range_;
  ::google::protobuf::uint32 tcp_flags_mask_;
  ::google::protobuf::uint32 tcp_flags_value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2facl_2facl_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessLists_Acl_Rule_Match_IpRule_Udp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acl.AccessLists.Acl.Rule.Match.IpRule.Udp) */ {
 public:
  AccessLists_Acl_Rule_Match_IpRule_Udp();
  virtual ~AccessLists_Acl_Rule_Match_IpRule_Udp();

  AccessLists_Acl_Rule_Match_IpRule_Udp(const AccessLists_Acl_Rule_Match_IpRule_Udp& from);

  inline AccessLists_Acl_Rule_Match_IpRule_Udp& operator=(const AccessLists_Acl_Rule_Match_IpRule_Udp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLists_Acl_Rule_Match_IpRule_Udp(AccessLists_Acl_Rule_Match_IpRule_Udp&& from) noexcept
    : AccessLists_Acl_Rule_Match_IpRule_Udp() {
    *this = ::std::move(from);
  }

  inline AccessLists_Acl_Rule_Match_IpRule_Udp& operator=(AccessLists_Acl_Rule_Match_IpRule_Udp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLists_Acl_Rule_Match_IpRule_Udp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLists_Acl_Rule_Match_IpRule_Udp* internal_default_instance() {
    return reinterpret_cast<const AccessLists_Acl_Rule_Match_IpRule_Udp*>(
               &_AccessLists_Acl_Rule_Match_IpRule_Udp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AccessLists_Acl_Rule_Match_IpRule_Udp* other);
  friend void swap(AccessLists_Acl_Rule_Match_IpRule_Udp& a, AccessLists_Acl_Rule_Match_IpRule_Udp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLists_Acl_Rule_Match_IpRule_Udp* New() const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule_Udp>(NULL);
  }

  AccessLists_Acl_Rule_Match_IpRule_Udp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule_Udp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLists_Acl_Rule_Match_IpRule_Udp& from);
  void MergeFrom(const AccessLists_Acl_Rule_Match_IpRule_Udp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLists_Acl_Rule_Match_IpRule_Udp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .acl.AccessLists.Acl.Rule.Match.IpRule.PortRange destination_port_range = 1;
  bool has_destination_port_range() const;
  void clear_destination_port_range();
  static const int kDestinationPortRangeFieldNumber = 1;
  private:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& _internal_destination_port_range() const;
  public:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& destination_port_range() const;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* release_destination_port_range();
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* mutable_destination_port_range();
  void set_allocated_destination_port_range(::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* destination_port_range);

  // .acl.AccessLists.Acl.Rule.Match.IpRule.PortRange source_port_range = 2;
  bool has_source_port_range() const;
  void clear_source_port_range();
  static const int kSourcePortRangeFieldNumber = 2;
  private:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& _internal_source_port_range() const;
  public:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& source_port_range() const;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* release_source_port_range();
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* mutable_source_port_range();
  void set_allocated_source_port_range(::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* source_port_range);

  // @@protoc_insertion_point(class_scope:acl.AccessLists.Acl.Rule.Match.IpRule.Udp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* destination_port_range_;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* source_port_range_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2facl_2facl_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessLists_Acl_Rule_Match_IpRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acl.AccessLists.Acl.Rule.Match.IpRule) */ {
 public:
  AccessLists_Acl_Rule_Match_IpRule();
  virtual ~AccessLists_Acl_Rule_Match_IpRule();

  AccessLists_Acl_Rule_Match_IpRule(const AccessLists_Acl_Rule_Match_IpRule& from);

  inline AccessLists_Acl_Rule_Match_IpRule& operator=(const AccessLists_Acl_Rule_Match_IpRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLists_Acl_Rule_Match_IpRule(AccessLists_Acl_Rule_Match_IpRule&& from) noexcept
    : AccessLists_Acl_Rule_Match_IpRule() {
    *this = ::std::move(from);
  }

  inline AccessLists_Acl_Rule_Match_IpRule& operator=(AccessLists_Acl_Rule_Match_IpRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLists_Acl_Rule_Match_IpRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLists_Acl_Rule_Match_IpRule* internal_default_instance() {
    return reinterpret_cast<const AccessLists_Acl_Rule_Match_IpRule*>(
               &_AccessLists_Acl_Rule_Match_IpRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(AccessLists_Acl_Rule_Match_IpRule* other);
  friend void swap(AccessLists_Acl_Rule_Match_IpRule& a, AccessLists_Acl_Rule_Match_IpRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLists_Acl_Rule_Match_IpRule* New() const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule>(NULL);
  }

  AccessLists_Acl_Rule_Match_IpRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_IpRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLists_Acl_Rule_Match_IpRule& from);
  void MergeFrom(const AccessLists_Acl_Rule_Match_IpRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLists_Acl_Rule_Match_IpRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AccessLists_Acl_Rule_Match_IpRule_Ip Ip;
  typedef AccessLists_Acl_Rule_Match_IpRule_Icmp Icmp;
  typedef AccessLists_Acl_Rule_Match_IpRule_PortRange PortRange;
  typedef AccessLists_Acl_Rule_Match_IpRule_Tcp Tcp;
  typedef AccessLists_Acl_Rule_Match_IpRule_Udp Udp;

  // accessors -------------------------------------------------------

  // .acl.AccessLists.Acl.Rule.Match.IpRule.Ip ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  private:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Ip& _internal_ip() const;
  public:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Ip& ip() const;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Ip* release_ip();
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Ip* mutable_ip();
  void set_allocated_ip(::acl::AccessLists_Acl_Rule_Match_IpRule_Ip* ip);

  // .acl.AccessLists.Acl.Rule.Match.IpRule.Icmp icmp = 2;
  bool has_icmp() const;
  void clear_icmp();
  static const int kIcmpFieldNumber = 2;
  private:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp& _internal_icmp() const;
  public:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp& icmp() const;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp* release_icmp();
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp* mutable_icmp();
  void set_allocated_icmp(::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp* icmp);

  // .acl.AccessLists.Acl.Rule.Match.IpRule.Tcp tcp = 3;
  bool has_tcp() const;
  void clear_tcp();
  static const int kTcpFieldNumber = 3;
  private:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp& _internal_tcp() const;
  public:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp& tcp() const;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp* release_tcp();
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp* mutable_tcp();
  void set_allocated_tcp(::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp* tcp);

  // .acl.AccessLists.Acl.Rule.Match.IpRule.Udp udp = 4;
  bool has_udp() const;
  void clear_udp();
  static const int kUdpFieldNumber = 4;
  private:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Udp& _internal_udp() const;
  public:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Udp& udp() const;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Udp* release_udp();
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Udp* mutable_udp();
  void set_allocated_udp(::acl::AccessLists_Acl_Rule_Match_IpRule_Udp* udp);

  // @@protoc_insertion_point(class_scope:acl.AccessLists.Acl.Rule.Match.IpRule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Ip* ip_;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp* icmp_;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp* tcp_;
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Udp* udp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2facl_2facl_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessLists_Acl_Rule_Match_MacIpRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acl.AccessLists.Acl.Rule.Match.MacIpRule) */ {
 public:
  AccessLists_Acl_Rule_Match_MacIpRule();
  virtual ~AccessLists_Acl_Rule_Match_MacIpRule();

  AccessLists_Acl_Rule_Match_MacIpRule(const AccessLists_Acl_Rule_Match_MacIpRule& from);

  inline AccessLists_Acl_Rule_Match_MacIpRule& operator=(const AccessLists_Acl_Rule_Match_MacIpRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLists_Acl_Rule_Match_MacIpRule(AccessLists_Acl_Rule_Match_MacIpRule&& from) noexcept
    : AccessLists_Acl_Rule_Match_MacIpRule() {
    *this = ::std::move(from);
  }

  inline AccessLists_Acl_Rule_Match_MacIpRule& operator=(AccessLists_Acl_Rule_Match_MacIpRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLists_Acl_Rule_Match_MacIpRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLists_Acl_Rule_Match_MacIpRule* internal_default_instance() {
    return reinterpret_cast<const AccessLists_Acl_Rule_Match_MacIpRule*>(
               &_AccessLists_Acl_Rule_Match_MacIpRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(AccessLists_Acl_Rule_Match_MacIpRule* other);
  friend void swap(AccessLists_Acl_Rule_Match_MacIpRule& a, AccessLists_Acl_Rule_Match_MacIpRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLists_Acl_Rule_Match_MacIpRule* New() const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_MacIpRule>(NULL);
  }

  AccessLists_Acl_Rule_Match_MacIpRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match_MacIpRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLists_Acl_Rule_Match_MacIpRule& from);
  void MergeFrom(const AccessLists_Acl_Rule_Match_MacIpRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLists_Acl_Rule_Match_MacIpRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string source_address = 1;
  void clear_source_address();
  static const int kSourceAddressFieldNumber = 1;
  const ::std::string& source_address() const;
  void set_source_address(const ::std::string& value);
  #if LANG_CXX11
  void set_source_address(::std::string&& value);
  #endif
  void set_source_address(const char* value);
  void set_source_address(const char* value, size_t size);
  ::std::string* mutable_source_address();
  ::std::string* release_source_address();
  void set_allocated_source_address(::std::string* source_address);

  // string source_mac_address = 3;
  void clear_source_mac_address();
  static const int kSourceMacAddressFieldNumber = 3;
  const ::std::string& source_mac_address() const;
  void set_source_mac_address(const ::std::string& value);
  #if LANG_CXX11
  void set_source_mac_address(::std::string&& value);
  #endif
  void set_source_mac_address(const char* value);
  void set_source_mac_address(const char* value, size_t size);
  ::std::string* mutable_source_mac_address();
  ::std::string* release_source_mac_address();
  void set_allocated_source_mac_address(::std::string* source_mac_address);

  // string source_mac_address_mask = 4;
  void clear_source_mac_address_mask();
  static const int kSourceMacAddressMaskFieldNumber = 4;
  const ::std::string& source_mac_address_mask() const;
  void set_source_mac_address_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_source_mac_address_mask(::std::string&& value);
  #endif
  void set_source_mac_address_mask(const char* value);
  void set_source_mac_address_mask(const char* value, size_t size);
  ::std::string* mutable_source_mac_address_mask();
  ::std::string* release_source_mac_address_mask();
  void set_allocated_source_mac_address_mask(::std::string* source_mac_address_mask);

  // uint32 source_address_prefix = 2;
  void clear_source_address_prefix();
  static const int kSourceAddressPrefixFieldNumber = 2;
  ::google::protobuf::uint32 source_address_prefix() const;
  void set_source_address_prefix(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:acl.AccessLists.Acl.Rule.Match.MacIpRule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr source_address_;
  ::google::protobuf::internal::ArenaStringPtr source_mac_address_;
  ::google::protobuf::internal::ArenaStringPtr source_mac_address_mask_;
  ::google::protobuf::uint32 source_address_prefix_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2facl_2facl_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessLists_Acl_Rule_Match : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acl.AccessLists.Acl.Rule.Match) */ {
 public:
  AccessLists_Acl_Rule_Match();
  virtual ~AccessLists_Acl_Rule_Match();

  AccessLists_Acl_Rule_Match(const AccessLists_Acl_Rule_Match& from);

  inline AccessLists_Acl_Rule_Match& operator=(const AccessLists_Acl_Rule_Match& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLists_Acl_Rule_Match(AccessLists_Acl_Rule_Match&& from) noexcept
    : AccessLists_Acl_Rule_Match() {
    *this = ::std::move(from);
  }

  inline AccessLists_Acl_Rule_Match& operator=(AccessLists_Acl_Rule_Match&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLists_Acl_Rule_Match& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLists_Acl_Rule_Match* internal_default_instance() {
    return reinterpret_cast<const AccessLists_Acl_Rule_Match*>(
               &_AccessLists_Acl_Rule_Match_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(AccessLists_Acl_Rule_Match* other);
  friend void swap(AccessLists_Acl_Rule_Match& a, AccessLists_Acl_Rule_Match& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLists_Acl_Rule_Match* New() const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match>(NULL);
  }

  AccessLists_Acl_Rule_Match* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule_Match>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLists_Acl_Rule_Match& from);
  void MergeFrom(const AccessLists_Acl_Rule_Match& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLists_Acl_Rule_Match* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AccessLists_Acl_Rule_Match_IpRule IpRule;
  typedef AccessLists_Acl_Rule_Match_MacIpRule MacIpRule;

  // accessors -------------------------------------------------------

  // .acl.AccessLists.Acl.Rule.Match.IpRule ip_rule = 1;
  bool has_ip_rule() const;
  void clear_ip_rule();
  static const int kIpRuleFieldNumber = 1;
  private:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule& _internal_ip_rule() const;
  public:
  const ::acl::AccessLists_Acl_Rule_Match_IpRule& ip_rule() const;
  ::acl::AccessLists_Acl_Rule_Match_IpRule* release_ip_rule();
  ::acl::AccessLists_Acl_Rule_Match_IpRule* mutable_ip_rule();
  void set_allocated_ip_rule(::acl::AccessLists_Acl_Rule_Match_IpRule* ip_rule);

  // .acl.AccessLists.Acl.Rule.Match.MacIpRule macip_rule = 2;
  bool has_macip_rule() const;
  void clear_macip_rule();
  static const int kMacipRuleFieldNumber = 2;
  private:
  const ::acl::AccessLists_Acl_Rule_Match_MacIpRule& _internal_macip_rule() const;
  public:
  const ::acl::AccessLists_Acl_Rule_Match_MacIpRule& macip_rule() const;
  ::acl::AccessLists_Acl_Rule_Match_MacIpRule* release_macip_rule();
  ::acl::AccessLists_Acl_Rule_Match_MacIpRule* mutable_macip_rule();
  void set_allocated_macip_rule(::acl::AccessLists_Acl_Rule_Match_MacIpRule* macip_rule);

  // @@protoc_insertion_point(class_scope:acl.AccessLists.Acl.Rule.Match)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::acl::AccessLists_Acl_Rule_Match_IpRule* ip_rule_;
  ::acl::AccessLists_Acl_Rule_Match_MacIpRule* macip_rule_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2facl_2facl_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessLists_Acl_Rule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acl.AccessLists.Acl.Rule) */ {
 public:
  AccessLists_Acl_Rule();
  virtual ~AccessLists_Acl_Rule();

  AccessLists_Acl_Rule(const AccessLists_Acl_Rule& from);

  inline AccessLists_Acl_Rule& operator=(const AccessLists_Acl_Rule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLists_Acl_Rule(AccessLists_Acl_Rule&& from) noexcept
    : AccessLists_Acl_Rule() {
    *this = ::std::move(from);
  }

  inline AccessLists_Acl_Rule& operator=(AccessLists_Acl_Rule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLists_Acl_Rule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLists_Acl_Rule* internal_default_instance() {
    return reinterpret_cast<const AccessLists_Acl_Rule*>(
               &_AccessLists_Acl_Rule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AccessLists_Acl_Rule* other);
  friend void swap(AccessLists_Acl_Rule& a, AccessLists_Acl_Rule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLists_Acl_Rule* New() const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule>(NULL);
  }

  AccessLists_Acl_Rule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLists_Acl_Rule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLists_Acl_Rule& from);
  void MergeFrom(const AccessLists_Acl_Rule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLists_Acl_Rule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AccessLists_Acl_Rule_Match Match;

  // accessors -------------------------------------------------------

  // string rule_name = 1;
  void clear_rule_name();
  static const int kRuleNameFieldNumber = 1;
  const ::std::string& rule_name() const;
  void set_rule_name(const ::std::string& value);
  #if LANG_CXX11
  void set_rule_name(::std::string&& value);
  #endif
  void set_rule_name(const char* value);
  void set_rule_name(const char* value, size_t size);
  ::std::string* mutable_rule_name();
  ::std::string* release_rule_name();
  void set_allocated_rule_name(::std::string* rule_name);

  // .acl.AccessLists.Acl.Rule.Match match = 3;
  bool has_match() const;
  void clear_match();
  static const int kMatchFieldNumber = 3;
  private:
  const ::acl::AccessLists_Acl_Rule_Match& _internal_match() const;
  public:
  const ::acl::AccessLists_Acl_Rule_Match& match() const;
  ::acl::AccessLists_Acl_Rule_Match* release_match();
  ::acl::AccessLists_Acl_Rule_Match* mutable_match();
  void set_allocated_match(::acl::AccessLists_Acl_Rule_Match* match);

  // .acl.AclAction acl_action = 2;
  void clear_acl_action();
  static const int kAclActionFieldNumber = 2;
  ::acl::AclAction acl_action() const;
  void set_acl_action(::acl::AclAction value);

  // @@protoc_insertion_point(class_scope:acl.AccessLists.Acl.Rule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr rule_name_;
  ::acl::AccessLists_Acl_Rule_Match* match_;
  int acl_action_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2facl_2facl_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessLists_Acl_Interfaces : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acl.AccessLists.Acl.Interfaces) */ {
 public:
  AccessLists_Acl_Interfaces();
  virtual ~AccessLists_Acl_Interfaces();

  AccessLists_Acl_Interfaces(const AccessLists_Acl_Interfaces& from);

  inline AccessLists_Acl_Interfaces& operator=(const AccessLists_Acl_Interfaces& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLists_Acl_Interfaces(AccessLists_Acl_Interfaces&& from) noexcept
    : AccessLists_Acl_Interfaces() {
    *this = ::std::move(from);
  }

  inline AccessLists_Acl_Interfaces& operator=(AccessLists_Acl_Interfaces&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLists_Acl_Interfaces& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLists_Acl_Interfaces* internal_default_instance() {
    return reinterpret_cast<const AccessLists_Acl_Interfaces*>(
               &_AccessLists_Acl_Interfaces_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(AccessLists_Acl_Interfaces* other);
  friend void swap(AccessLists_Acl_Interfaces& a, AccessLists_Acl_Interfaces& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLists_Acl_Interfaces* New() const final {
    return CreateMaybeMessage<AccessLists_Acl_Interfaces>(NULL);
  }

  AccessLists_Acl_Interfaces* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLists_Acl_Interfaces>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLists_Acl_Interfaces& from);
  void MergeFrom(const AccessLists_Acl_Interfaces& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLists_Acl_Interfaces* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string egress = 1;
  int egress_size() const;
  void clear_egress();
  static const int kEgressFieldNumber = 1;
  const ::std::string& egress(int index) const;
  ::std::string* mutable_egress(int index);
  void set_egress(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_egress(int index, ::std::string&& value);
  #endif
  void set_egress(int index, const char* value);
  void set_egress(int index, const char* value, size_t size);
  ::std::string* add_egress();
  void add_egress(const ::std::string& value);
  #if LANG_CXX11
  void add_egress(::std::string&& value);
  #endif
  void add_egress(const char* value);
  void add_egress(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& egress() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_egress();

  // repeated string ingress = 2;
  int ingress_size() const;
  void clear_ingress();
  static const int kIngressFieldNumber = 2;
  const ::std::string& ingress(int index) const;
  ::std::string* mutable_ingress(int index);
  void set_ingress(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ingress(int index, ::std::string&& value);
  #endif
  void set_ingress(int index, const char* value);
  void set_ingress(int index, const char* value, size_t size);
  ::std::string* add_ingress();
  void add_ingress(const ::std::string& value);
  #if LANG_CXX11
  void add_ingress(::std::string&& value);
  #endif
  void add_ingress(const char* value);
  void add_ingress(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ingress() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ingress();

  // @@protoc_insertion_point(class_scope:acl.AccessLists.Acl.Interfaces)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> egress_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ingress_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2facl_2facl_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessLists_Acl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acl.AccessLists.Acl) */ {
 public:
  AccessLists_Acl();
  virtual ~AccessLists_Acl();

  AccessLists_Acl(const AccessLists_Acl& from);

  inline AccessLists_Acl& operator=(const AccessLists_Acl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLists_Acl(AccessLists_Acl&& from) noexcept
    : AccessLists_Acl() {
    *this = ::std::move(from);
  }

  inline AccessLists_Acl& operator=(AccessLists_Acl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLists_Acl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLists_Acl* internal_default_instance() {
    return reinterpret_cast<const AccessLists_Acl*>(
               &_AccessLists_Acl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(AccessLists_Acl* other);
  friend void swap(AccessLists_Acl& a, AccessLists_Acl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLists_Acl* New() const final {
    return CreateMaybeMessage<AccessLists_Acl>(NULL);
  }

  AccessLists_Acl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLists_Acl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLists_Acl& from);
  void MergeFrom(const AccessLists_Acl& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLists_Acl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AccessLists_Acl_Rule Rule;
  typedef AccessLists_Acl_Interfaces Interfaces;

  // accessors -------------------------------------------------------

  // repeated .acl.AccessLists.Acl.Rule rules = 2;
  int rules_size() const;
  void clear_rules();
  static const int kRulesFieldNumber = 2;
  ::acl::AccessLists_Acl_Rule* mutable_rules(int index);
  ::google::protobuf::RepeatedPtrField< ::acl::AccessLists_Acl_Rule >*
      mutable_rules();
  const ::acl::AccessLists_Acl_Rule& rules(int index) const;
  ::acl::AccessLists_Acl_Rule* add_rules();
  const ::google::protobuf::RepeatedPtrField< ::acl::AccessLists_Acl_Rule >&
      rules() const;

  // string acl_name = 1;
  void clear_acl_name();
  static const int kAclNameFieldNumber = 1;
  const ::std::string& acl_name() const;
  void set_acl_name(const ::std::string& value);
  #if LANG_CXX11
  void set_acl_name(::std::string&& value);
  #endif
  void set_acl_name(const char* value);
  void set_acl_name(const char* value, size_t size);
  ::std::string* mutable_acl_name();
  ::std::string* release_acl_name();
  void set_allocated_acl_name(::std::string* acl_name);

  // .acl.AccessLists.Acl.Interfaces interfaces = 3;
  bool has_interfaces() const;
  void clear_interfaces();
  static const int kInterfacesFieldNumber = 3;
  private:
  const ::acl::AccessLists_Acl_Interfaces& _internal_interfaces() const;
  public:
  const ::acl::AccessLists_Acl_Interfaces& interfaces() const;
  ::acl::AccessLists_Acl_Interfaces* release_interfaces();
  ::acl::AccessLists_Acl_Interfaces* mutable_interfaces();
  void set_allocated_interfaces(::acl::AccessLists_Acl_Interfaces* interfaces);

  // @@protoc_insertion_point(class_scope:acl.AccessLists.Acl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::acl::AccessLists_Acl_Rule > rules_;
  ::google::protobuf::internal::ArenaStringPtr acl_name_;
  ::acl::AccessLists_Acl_Interfaces* interfaces_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2facl_2facl_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessLists : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acl.AccessLists) */ {
 public:
  AccessLists();
  virtual ~AccessLists();

  AccessLists(const AccessLists& from);

  inline AccessLists& operator=(const AccessLists& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLists(AccessLists&& from) noexcept
    : AccessLists() {
    *this = ::std::move(from);
  }

  inline AccessLists& operator=(AccessLists&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessLists& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLists* internal_default_instance() {
    return reinterpret_cast<const AccessLists*>(
               &_AccessLists_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(AccessLists* other);
  friend void swap(AccessLists& a, AccessLists& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLists* New() const final {
    return CreateMaybeMessage<AccessLists>(NULL);
  }

  AccessLists* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLists>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLists& from);
  void MergeFrom(const AccessLists& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLists* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AccessLists_Acl Acl;

  // accessors -------------------------------------------------------

  // repeated .acl.AccessLists.Acl acls = 1;
  int acls_size() const;
  void clear_acls();
  static const int kAclsFieldNumber = 1;
  ::acl::AccessLists_Acl* mutable_acls(int index);
  ::google::protobuf::RepeatedPtrField< ::acl::AccessLists_Acl >*
      mutable_acls();
  const ::acl::AccessLists_Acl& acls(int index) const;
  ::acl::AccessLists_Acl* add_acls();
  const ::google::protobuf::RepeatedPtrField< ::acl::AccessLists_Acl >&
      acls() const;

  // @@protoc_insertion_point(class_scope:acl.AccessLists)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::acl::AccessLists_Acl > acls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2facl_2facl_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AccessLists_Acl_Rule_Match_IpRule_Ip

// string destination_network = 1;
inline void AccessLists_Acl_Rule_Match_IpRule_Ip::clear_destination_network() {
  destination_network_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLists_Acl_Rule_Match_IpRule_Ip::destination_network() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.destination_network)
  return destination_network_.GetNoArena();
}
inline void AccessLists_Acl_Rule_Match_IpRule_Ip::set_destination_network(const ::std::string& value) {
  
  destination_network_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.destination_network)
}
#if LANG_CXX11
inline void AccessLists_Acl_Rule_Match_IpRule_Ip::set_destination_network(::std::string&& value) {
  
  destination_network_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.destination_network)
}
#endif
inline void AccessLists_Acl_Rule_Match_IpRule_Ip::set_destination_network(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destination_network_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.destination_network)
}
inline void AccessLists_Acl_Rule_Match_IpRule_Ip::set_destination_network(const char* value, size_t size) {
  
  destination_network_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.destination_network)
}
inline ::std::string* AccessLists_Acl_Rule_Match_IpRule_Ip::mutable_destination_network() {
  
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.destination_network)
  return destination_network_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLists_Acl_Rule_Match_IpRule_Ip::release_destination_network() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.destination_network)
  
  return destination_network_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLists_Acl_Rule_Match_IpRule_Ip::set_allocated_destination_network(::std::string* destination_network) {
  if (destination_network != NULL) {
    
  } else {
    
  }
  destination_network_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination_network);
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.destination_network)
}

// string source_network = 2;
inline void AccessLists_Acl_Rule_Match_IpRule_Ip::clear_source_network() {
  source_network_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLists_Acl_Rule_Match_IpRule_Ip::source_network() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.source_network)
  return source_network_.GetNoArena();
}
inline void AccessLists_Acl_Rule_Match_IpRule_Ip::set_source_network(const ::std::string& value) {
  
  source_network_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.source_network)
}
#if LANG_CXX11
inline void AccessLists_Acl_Rule_Match_IpRule_Ip::set_source_network(::std::string&& value) {
  
  source_network_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.source_network)
}
#endif
inline void AccessLists_Acl_Rule_Match_IpRule_Ip::set_source_network(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_network_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.source_network)
}
inline void AccessLists_Acl_Rule_Match_IpRule_Ip::set_source_network(const char* value, size_t size) {
  
  source_network_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.source_network)
}
inline ::std::string* AccessLists_Acl_Rule_Match_IpRule_Ip::mutable_source_network() {
  
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.source_network)
  return source_network_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLists_Acl_Rule_Match_IpRule_Ip::release_source_network() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.source_network)
  
  return source_network_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLists_Acl_Rule_Match_IpRule_Ip::set_allocated_source_network(::std::string* source_network) {
  if (source_network != NULL) {
    
  } else {
    
  }
  source_network_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_network);
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.IpRule.Ip.source_network)
}

// -------------------------------------------------------------------

// AccessLists_Acl_Rule_Match_IpRule_Icmp_Range

// uint32 first = 1;
inline void AccessLists_Acl_Rule_Match_IpRule_Icmp_Range::clear_first() {
  first_ = 0u;
}
inline ::google::protobuf::uint32 AccessLists_Acl_Rule_Match_IpRule_Icmp_Range::first() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.Range.first)
  return first_;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Icmp_Range::set_first(::google::protobuf::uint32 value) {
  
  first_ = value;
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.Range.first)
}

// uint32 last = 2;
inline void AccessLists_Acl_Rule_Match_IpRule_Icmp_Range::clear_last() {
  last_ = 0u;
}
inline ::google::protobuf::uint32 AccessLists_Acl_Rule_Match_IpRule_Icmp_Range::last() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.Range.last)
  return last_;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Icmp_Range::set_last(::google::protobuf::uint32 value) {
  
  last_ = value;
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.Range.last)
}

// -------------------------------------------------------------------

// AccessLists_Acl_Rule_Match_IpRule_Icmp

// bool icmpv6 = 1;
inline void AccessLists_Acl_Rule_Match_IpRule_Icmp::clear_icmpv6() {
  icmpv6_ = false;
}
inline bool AccessLists_Acl_Rule_Match_IpRule_Icmp::icmpv6() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.icmpv6)
  return icmpv6_;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Icmp::set_icmpv6(bool value) {
  
  icmpv6_ = value;
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.icmpv6)
}

// .acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.Range icmp_code_range = 2;
inline bool AccessLists_Acl_Rule_Match_IpRule_Icmp::has_icmp_code_range() const {
  return this != internal_default_instance() && icmp_code_range_ != NULL;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Icmp::clear_icmp_code_range() {
  if (GetArenaNoVirtual() == NULL && icmp_code_range_ != NULL) {
    delete icmp_code_range_;
  }
  icmp_code_range_ = NULL;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& AccessLists_Acl_Rule_Match_IpRule_Icmp::_internal_icmp_code_range() const {
  return *icmp_code_range_;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& AccessLists_Acl_Rule_Match_IpRule_Icmp::icmp_code_range() const {
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* p = icmp_code_range_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.icmp_code_range)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range*>(
      &::acl::_AccessLists_Acl_Rule_Match_IpRule_Icmp_Range_default_instance_);
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* AccessLists_Acl_Rule_Match_IpRule_Icmp::release_icmp_code_range() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.icmp_code_range)
  
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* temp = icmp_code_range_;
  icmp_code_range_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* AccessLists_Acl_Rule_Match_IpRule_Icmp::mutable_icmp_code_range() {
  
  if (icmp_code_range_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range>(GetArenaNoVirtual());
    icmp_code_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.icmp_code_range)
  return icmp_code_range_;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Icmp::set_allocated_icmp_code_range(::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* icmp_code_range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete icmp_code_range_;
  }
  if (icmp_code_range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      icmp_code_range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, icmp_code_range, submessage_arena);
    }
    
  } else {
    
  }
  icmp_code_range_ = icmp_code_range;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.icmp_code_range)
}

// .acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.Range icmp_type_range = 3;
inline bool AccessLists_Acl_Rule_Match_IpRule_Icmp::has_icmp_type_range() const {
  return this != internal_default_instance() && icmp_type_range_ != NULL;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Icmp::clear_icmp_type_range() {
  if (GetArenaNoVirtual() == NULL && icmp_type_range_ != NULL) {
    delete icmp_type_range_;
  }
  icmp_type_range_ = NULL;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& AccessLists_Acl_Rule_Match_IpRule_Icmp::_internal_icmp_type_range() const {
  return *icmp_type_range_;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range& AccessLists_Acl_Rule_Match_IpRule_Icmp::icmp_type_range() const {
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* p = icmp_type_range_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.icmp_type_range)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range*>(
      &::acl::_AccessLists_Acl_Rule_Match_IpRule_Icmp_Range_default_instance_);
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* AccessLists_Acl_Rule_Match_IpRule_Icmp::release_icmp_type_range() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.icmp_type_range)
  
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* temp = icmp_type_range_;
  icmp_type_range_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* AccessLists_Acl_Rule_Match_IpRule_Icmp::mutable_icmp_type_range() {
  
  if (icmp_type_range_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range>(GetArenaNoVirtual());
    icmp_type_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.icmp_type_range)
  return icmp_type_range_;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Icmp::set_allocated_icmp_type_range(::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp_Range* icmp_type_range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete icmp_type_range_;
  }
  if (icmp_type_range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      icmp_type_range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, icmp_type_range, submessage_arena);
    }
    
  } else {
    
  }
  icmp_type_range_ = icmp_type_range;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.IpRule.Icmp.icmp_type_range)
}

// -------------------------------------------------------------------

// AccessLists_Acl_Rule_Match_IpRule_PortRange

// uint32 lower_port = 1;
inline void AccessLists_Acl_Rule_Match_IpRule_PortRange::clear_lower_port() {
  lower_port_ = 0u;
}
inline ::google::protobuf::uint32 AccessLists_Acl_Rule_Match_IpRule_PortRange::lower_port() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.PortRange.lower_port)
  return lower_port_;
}
inline void AccessLists_Acl_Rule_Match_IpRule_PortRange::set_lower_port(::google::protobuf::uint32 value) {
  
  lower_port_ = value;
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.Match.IpRule.PortRange.lower_port)
}

// uint32 upper_port = 2;
inline void AccessLists_Acl_Rule_Match_IpRule_PortRange::clear_upper_port() {
  upper_port_ = 0u;
}
inline ::google::protobuf::uint32 AccessLists_Acl_Rule_Match_IpRule_PortRange::upper_port() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.PortRange.upper_port)
  return upper_port_;
}
inline void AccessLists_Acl_Rule_Match_IpRule_PortRange::set_upper_port(::google::protobuf::uint32 value) {
  
  upper_port_ = value;
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.Match.IpRule.PortRange.upper_port)
}

// -------------------------------------------------------------------

// AccessLists_Acl_Rule_Match_IpRule_Tcp

// .acl.AccessLists.Acl.Rule.Match.IpRule.PortRange destination_port_range = 1;
inline bool AccessLists_Acl_Rule_Match_IpRule_Tcp::has_destination_port_range() const {
  return this != internal_default_instance() && destination_port_range_ != NULL;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Tcp::clear_destination_port_range() {
  if (GetArenaNoVirtual() == NULL && destination_port_range_ != NULL) {
    delete destination_port_range_;
  }
  destination_port_range_ = NULL;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& AccessLists_Acl_Rule_Match_IpRule_Tcp::_internal_destination_port_range() const {
  return *destination_port_range_;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& AccessLists_Acl_Rule_Match_IpRule_Tcp::destination_port_range() const {
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* p = destination_port_range_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp.destination_port_range)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange*>(
      &::acl::_AccessLists_Acl_Rule_Match_IpRule_PortRange_default_instance_);
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* AccessLists_Acl_Rule_Match_IpRule_Tcp::release_destination_port_range() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp.destination_port_range)
  
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* temp = destination_port_range_;
  destination_port_range_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* AccessLists_Acl_Rule_Match_IpRule_Tcp::mutable_destination_port_range() {
  
  if (destination_port_range_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange>(GetArenaNoVirtual());
    destination_port_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp.destination_port_range)
  return destination_port_range_;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Tcp::set_allocated_destination_port_range(::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* destination_port_range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete destination_port_range_;
  }
  if (destination_port_range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      destination_port_range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, destination_port_range, submessage_arena);
    }
    
  } else {
    
  }
  destination_port_range_ = destination_port_range;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp.destination_port_range)
}

// .acl.AccessLists.Acl.Rule.Match.IpRule.PortRange source_port_range = 2;
inline bool AccessLists_Acl_Rule_Match_IpRule_Tcp::has_source_port_range() const {
  return this != internal_default_instance() && source_port_range_ != NULL;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Tcp::clear_source_port_range() {
  if (GetArenaNoVirtual() == NULL && source_port_range_ != NULL) {
    delete source_port_range_;
  }
  source_port_range_ = NULL;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& AccessLists_Acl_Rule_Match_IpRule_Tcp::_internal_source_port_range() const {
  return *source_port_range_;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& AccessLists_Acl_Rule_Match_IpRule_Tcp::source_port_range() const {
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* p = source_port_range_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp.source_port_range)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange*>(
      &::acl::_AccessLists_Acl_Rule_Match_IpRule_PortRange_default_instance_);
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* AccessLists_Acl_Rule_Match_IpRule_Tcp::release_source_port_range() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp.source_port_range)
  
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* temp = source_port_range_;
  source_port_range_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* AccessLists_Acl_Rule_Match_IpRule_Tcp::mutable_source_port_range() {
  
  if (source_port_range_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange>(GetArenaNoVirtual());
    source_port_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp.source_port_range)
  return source_port_range_;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Tcp::set_allocated_source_port_range(::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* source_port_range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_port_range_;
  }
  if (source_port_range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_port_range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_port_range, submessage_arena);
    }
    
  } else {
    
  }
  source_port_range_ = source_port_range;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp.source_port_range)
}

// uint32 tcp_flags_mask = 3;
inline void AccessLists_Acl_Rule_Match_IpRule_Tcp::clear_tcp_flags_mask() {
  tcp_flags_mask_ = 0u;
}
inline ::google::protobuf::uint32 AccessLists_Acl_Rule_Match_IpRule_Tcp::tcp_flags_mask() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp.tcp_flags_mask)
  return tcp_flags_mask_;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Tcp::set_tcp_flags_mask(::google::protobuf::uint32 value) {
  
  tcp_flags_mask_ = value;
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp.tcp_flags_mask)
}

// uint32 tcp_flags_value = 4;
inline void AccessLists_Acl_Rule_Match_IpRule_Tcp::clear_tcp_flags_value() {
  tcp_flags_value_ = 0u;
}
inline ::google::protobuf::uint32 AccessLists_Acl_Rule_Match_IpRule_Tcp::tcp_flags_value() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp.tcp_flags_value)
  return tcp_flags_value_;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Tcp::set_tcp_flags_value(::google::protobuf::uint32 value) {
  
  tcp_flags_value_ = value;
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.Match.IpRule.Tcp.tcp_flags_value)
}

// -------------------------------------------------------------------

// AccessLists_Acl_Rule_Match_IpRule_Udp

// .acl.AccessLists.Acl.Rule.Match.IpRule.PortRange destination_port_range = 1;
inline bool AccessLists_Acl_Rule_Match_IpRule_Udp::has_destination_port_range() const {
  return this != internal_default_instance() && destination_port_range_ != NULL;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Udp::clear_destination_port_range() {
  if (GetArenaNoVirtual() == NULL && destination_port_range_ != NULL) {
    delete destination_port_range_;
  }
  destination_port_range_ = NULL;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& AccessLists_Acl_Rule_Match_IpRule_Udp::_internal_destination_port_range() const {
  return *destination_port_range_;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& AccessLists_Acl_Rule_Match_IpRule_Udp::destination_port_range() const {
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* p = destination_port_range_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.Udp.destination_port_range)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange*>(
      &::acl::_AccessLists_Acl_Rule_Match_IpRule_PortRange_default_instance_);
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* AccessLists_Acl_Rule_Match_IpRule_Udp::release_destination_port_range() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.IpRule.Udp.destination_port_range)
  
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* temp = destination_port_range_;
  destination_port_range_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* AccessLists_Acl_Rule_Match_IpRule_Udp::mutable_destination_port_range() {
  
  if (destination_port_range_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange>(GetArenaNoVirtual());
    destination_port_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.IpRule.Udp.destination_port_range)
  return destination_port_range_;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Udp::set_allocated_destination_port_range(::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* destination_port_range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete destination_port_range_;
  }
  if (destination_port_range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      destination_port_range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, destination_port_range, submessage_arena);
    }
    
  } else {
    
  }
  destination_port_range_ = destination_port_range;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.IpRule.Udp.destination_port_range)
}

// .acl.AccessLists.Acl.Rule.Match.IpRule.PortRange source_port_range = 2;
inline bool AccessLists_Acl_Rule_Match_IpRule_Udp::has_source_port_range() const {
  return this != internal_default_instance() && source_port_range_ != NULL;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Udp::clear_source_port_range() {
  if (GetArenaNoVirtual() == NULL && source_port_range_ != NULL) {
    delete source_port_range_;
  }
  source_port_range_ = NULL;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& AccessLists_Acl_Rule_Match_IpRule_Udp::_internal_source_port_range() const {
  return *source_port_range_;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange& AccessLists_Acl_Rule_Match_IpRule_Udp::source_port_range() const {
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* p = source_port_range_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.Udp.source_port_range)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange*>(
      &::acl::_AccessLists_Acl_Rule_Match_IpRule_PortRange_default_instance_);
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* AccessLists_Acl_Rule_Match_IpRule_Udp::release_source_port_range() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.IpRule.Udp.source_port_range)
  
  ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* temp = source_port_range_;
  source_port_range_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* AccessLists_Acl_Rule_Match_IpRule_Udp::mutable_source_port_range() {
  
  if (source_port_range_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange>(GetArenaNoVirtual());
    source_port_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.IpRule.Udp.source_port_range)
  return source_port_range_;
}
inline void AccessLists_Acl_Rule_Match_IpRule_Udp::set_allocated_source_port_range(::acl::AccessLists_Acl_Rule_Match_IpRule_PortRange* source_port_range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_port_range_;
  }
  if (source_port_range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_port_range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_port_range, submessage_arena);
    }
    
  } else {
    
  }
  source_port_range_ = source_port_range;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.IpRule.Udp.source_port_range)
}

// -------------------------------------------------------------------

// AccessLists_Acl_Rule_Match_IpRule

// .acl.AccessLists.Acl.Rule.Match.IpRule.Ip ip = 1;
inline bool AccessLists_Acl_Rule_Match_IpRule::has_ip() const {
  return this != internal_default_instance() && ip_ != NULL;
}
inline void AccessLists_Acl_Rule_Match_IpRule::clear_ip() {
  if (GetArenaNoVirtual() == NULL && ip_ != NULL) {
    delete ip_;
  }
  ip_ = NULL;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_Ip& AccessLists_Acl_Rule_Match_IpRule::_internal_ip() const {
  return *ip_;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_Ip& AccessLists_Acl_Rule_Match_IpRule::ip() const {
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Ip* p = ip_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.ip)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Rule_Match_IpRule_Ip*>(
      &::acl::_AccessLists_Acl_Rule_Match_IpRule_Ip_default_instance_);
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_Ip* AccessLists_Acl_Rule_Match_IpRule::release_ip() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.IpRule.ip)
  
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Ip* temp = ip_;
  ip_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_Ip* AccessLists_Acl_Rule_Match_IpRule::mutable_ip() {
  
  if (ip_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_Ip>(GetArenaNoVirtual());
    ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.IpRule.ip)
  return ip_;
}
inline void AccessLists_Acl_Rule_Match_IpRule::set_allocated_ip(::acl::AccessLists_Acl_Rule_Match_IpRule_Ip* ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ip_;
  }
  if (ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ip, submessage_arena);
    }
    
  } else {
    
  }
  ip_ = ip;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.IpRule.ip)
}

// .acl.AccessLists.Acl.Rule.Match.IpRule.Icmp icmp = 2;
inline bool AccessLists_Acl_Rule_Match_IpRule::has_icmp() const {
  return this != internal_default_instance() && icmp_ != NULL;
}
inline void AccessLists_Acl_Rule_Match_IpRule::clear_icmp() {
  if (GetArenaNoVirtual() == NULL && icmp_ != NULL) {
    delete icmp_;
  }
  icmp_ = NULL;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp& AccessLists_Acl_Rule_Match_IpRule::_internal_icmp() const {
  return *icmp_;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp& AccessLists_Acl_Rule_Match_IpRule::icmp() const {
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp* p = icmp_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.icmp)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp*>(
      &::acl::_AccessLists_Acl_Rule_Match_IpRule_Icmp_default_instance_);
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp* AccessLists_Acl_Rule_Match_IpRule::release_icmp() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.IpRule.icmp)
  
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp* temp = icmp_;
  icmp_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp* AccessLists_Acl_Rule_Match_IpRule::mutable_icmp() {
  
  if (icmp_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp>(GetArenaNoVirtual());
    icmp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.IpRule.icmp)
  return icmp_;
}
inline void AccessLists_Acl_Rule_Match_IpRule::set_allocated_icmp(::acl::AccessLists_Acl_Rule_Match_IpRule_Icmp* icmp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete icmp_;
  }
  if (icmp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      icmp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, icmp, submessage_arena);
    }
    
  } else {
    
  }
  icmp_ = icmp;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.IpRule.icmp)
}

// .acl.AccessLists.Acl.Rule.Match.IpRule.Tcp tcp = 3;
inline bool AccessLists_Acl_Rule_Match_IpRule::has_tcp() const {
  return this != internal_default_instance() && tcp_ != NULL;
}
inline void AccessLists_Acl_Rule_Match_IpRule::clear_tcp() {
  if (GetArenaNoVirtual() == NULL && tcp_ != NULL) {
    delete tcp_;
  }
  tcp_ = NULL;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp& AccessLists_Acl_Rule_Match_IpRule::_internal_tcp() const {
  return *tcp_;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp& AccessLists_Acl_Rule_Match_IpRule::tcp() const {
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp* p = tcp_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.tcp)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp*>(
      &::acl::_AccessLists_Acl_Rule_Match_IpRule_Tcp_default_instance_);
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp* AccessLists_Acl_Rule_Match_IpRule::release_tcp() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.IpRule.tcp)
  
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp* temp = tcp_;
  tcp_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp* AccessLists_Acl_Rule_Match_IpRule::mutable_tcp() {
  
  if (tcp_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp>(GetArenaNoVirtual());
    tcp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.IpRule.tcp)
  return tcp_;
}
inline void AccessLists_Acl_Rule_Match_IpRule::set_allocated_tcp(::acl::AccessLists_Acl_Rule_Match_IpRule_Tcp* tcp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tcp_;
  }
  if (tcp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tcp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tcp, submessage_arena);
    }
    
  } else {
    
  }
  tcp_ = tcp;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.IpRule.tcp)
}

// .acl.AccessLists.Acl.Rule.Match.IpRule.Udp udp = 4;
inline bool AccessLists_Acl_Rule_Match_IpRule::has_udp() const {
  return this != internal_default_instance() && udp_ != NULL;
}
inline void AccessLists_Acl_Rule_Match_IpRule::clear_udp() {
  if (GetArenaNoVirtual() == NULL && udp_ != NULL) {
    delete udp_;
  }
  udp_ = NULL;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_Udp& AccessLists_Acl_Rule_Match_IpRule::_internal_udp() const {
  return *udp_;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule_Udp& AccessLists_Acl_Rule_Match_IpRule::udp() const {
  const ::acl::AccessLists_Acl_Rule_Match_IpRule_Udp* p = udp_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.IpRule.udp)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Rule_Match_IpRule_Udp*>(
      &::acl::_AccessLists_Acl_Rule_Match_IpRule_Udp_default_instance_);
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_Udp* AccessLists_Acl_Rule_Match_IpRule::release_udp() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.IpRule.udp)
  
  ::acl::AccessLists_Acl_Rule_Match_IpRule_Udp* temp = udp_;
  udp_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule_Udp* AccessLists_Acl_Rule_Match_IpRule::mutable_udp() {
  
  if (udp_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule_Udp>(GetArenaNoVirtual());
    udp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.IpRule.udp)
  return udp_;
}
inline void AccessLists_Acl_Rule_Match_IpRule::set_allocated_udp(::acl::AccessLists_Acl_Rule_Match_IpRule_Udp* udp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete udp_;
  }
  if (udp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      udp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, udp, submessage_arena);
    }
    
  } else {
    
  }
  udp_ = udp;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.IpRule.udp)
}

// -------------------------------------------------------------------

// AccessLists_Acl_Rule_Match_MacIpRule

// string source_address = 1;
inline void AccessLists_Acl_Rule_Match_MacIpRule::clear_source_address() {
  source_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLists_Acl_Rule_Match_MacIpRule::source_address() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_address)
  return source_address_.GetNoArena();
}
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_source_address(const ::std::string& value) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_address)
}
#if LANG_CXX11
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_source_address(::std::string&& value) {
  
  source_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_address)
}
#endif
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_source_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_address)
}
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_source_address(const char* value, size_t size) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_address)
}
inline ::std::string* AccessLists_Acl_Rule_Match_MacIpRule::mutable_source_address() {
  
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_address)
  return source_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLists_Acl_Rule_Match_MacIpRule::release_source_address() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_address)
  
  return source_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_allocated_source_address(::std::string* source_address) {
  if (source_address != NULL) {
    
  } else {
    
  }
  source_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_address);
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_address)
}

// uint32 source_address_prefix = 2;
inline void AccessLists_Acl_Rule_Match_MacIpRule::clear_source_address_prefix() {
  source_address_prefix_ = 0u;
}
inline ::google::protobuf::uint32 AccessLists_Acl_Rule_Match_MacIpRule::source_address_prefix() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_address_prefix)
  return source_address_prefix_;
}
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_source_address_prefix(::google::protobuf::uint32 value) {
  
  source_address_prefix_ = value;
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_address_prefix)
}

// string source_mac_address = 3;
inline void AccessLists_Acl_Rule_Match_MacIpRule::clear_source_mac_address() {
  source_mac_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLists_Acl_Rule_Match_MacIpRule::source_mac_address() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address)
  return source_mac_address_.GetNoArena();
}
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_source_mac_address(const ::std::string& value) {
  
  source_mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address)
}
#if LANG_CXX11
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_source_mac_address(::std::string&& value) {
  
  source_mac_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address)
}
#endif
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_source_mac_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address)
}
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_source_mac_address(const char* value, size_t size) {
  
  source_mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address)
}
inline ::std::string* AccessLists_Acl_Rule_Match_MacIpRule::mutable_source_mac_address() {
  
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address)
  return source_mac_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLists_Acl_Rule_Match_MacIpRule::release_source_mac_address() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address)
  
  return source_mac_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_allocated_source_mac_address(::std::string* source_mac_address) {
  if (source_mac_address != NULL) {
    
  } else {
    
  }
  source_mac_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_mac_address);
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address)
}

// string source_mac_address_mask = 4;
inline void AccessLists_Acl_Rule_Match_MacIpRule::clear_source_mac_address_mask() {
  source_mac_address_mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLists_Acl_Rule_Match_MacIpRule::source_mac_address_mask() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address_mask)
  return source_mac_address_mask_.GetNoArena();
}
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_source_mac_address_mask(const ::std::string& value) {
  
  source_mac_address_mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address_mask)
}
#if LANG_CXX11
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_source_mac_address_mask(::std::string&& value) {
  
  source_mac_address_mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address_mask)
}
#endif
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_source_mac_address_mask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_mac_address_mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address_mask)
}
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_source_mac_address_mask(const char* value, size_t size) {
  
  source_mac_address_mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address_mask)
}
inline ::std::string* AccessLists_Acl_Rule_Match_MacIpRule::mutable_source_mac_address_mask() {
  
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address_mask)
  return source_mac_address_mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLists_Acl_Rule_Match_MacIpRule::release_source_mac_address_mask() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address_mask)
  
  return source_mac_address_mask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLists_Acl_Rule_Match_MacIpRule::set_allocated_source_mac_address_mask(::std::string* source_mac_address_mask) {
  if (source_mac_address_mask != NULL) {
    
  } else {
    
  }
  source_mac_address_mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_mac_address_mask);
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.MacIpRule.source_mac_address_mask)
}

// -------------------------------------------------------------------

// AccessLists_Acl_Rule_Match

// .acl.AccessLists.Acl.Rule.Match.IpRule ip_rule = 1;
inline bool AccessLists_Acl_Rule_Match::has_ip_rule() const {
  return this != internal_default_instance() && ip_rule_ != NULL;
}
inline void AccessLists_Acl_Rule_Match::clear_ip_rule() {
  if (GetArenaNoVirtual() == NULL && ip_rule_ != NULL) {
    delete ip_rule_;
  }
  ip_rule_ = NULL;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule& AccessLists_Acl_Rule_Match::_internal_ip_rule() const {
  return *ip_rule_;
}
inline const ::acl::AccessLists_Acl_Rule_Match_IpRule& AccessLists_Acl_Rule_Match::ip_rule() const {
  const ::acl::AccessLists_Acl_Rule_Match_IpRule* p = ip_rule_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.ip_rule)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Rule_Match_IpRule*>(
      &::acl::_AccessLists_Acl_Rule_Match_IpRule_default_instance_);
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule* AccessLists_Acl_Rule_Match::release_ip_rule() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.ip_rule)
  
  ::acl::AccessLists_Acl_Rule_Match_IpRule* temp = ip_rule_;
  ip_rule_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Rule_Match_IpRule* AccessLists_Acl_Rule_Match::mutable_ip_rule() {
  
  if (ip_rule_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_IpRule>(GetArenaNoVirtual());
    ip_rule_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.ip_rule)
  return ip_rule_;
}
inline void AccessLists_Acl_Rule_Match::set_allocated_ip_rule(::acl::AccessLists_Acl_Rule_Match_IpRule* ip_rule) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ip_rule_;
  }
  if (ip_rule) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ip_rule = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ip_rule, submessage_arena);
    }
    
  } else {
    
  }
  ip_rule_ = ip_rule;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.ip_rule)
}

// .acl.AccessLists.Acl.Rule.Match.MacIpRule macip_rule = 2;
inline bool AccessLists_Acl_Rule_Match::has_macip_rule() const {
  return this != internal_default_instance() && macip_rule_ != NULL;
}
inline void AccessLists_Acl_Rule_Match::clear_macip_rule() {
  if (GetArenaNoVirtual() == NULL && macip_rule_ != NULL) {
    delete macip_rule_;
  }
  macip_rule_ = NULL;
}
inline const ::acl::AccessLists_Acl_Rule_Match_MacIpRule& AccessLists_Acl_Rule_Match::_internal_macip_rule() const {
  return *macip_rule_;
}
inline const ::acl::AccessLists_Acl_Rule_Match_MacIpRule& AccessLists_Acl_Rule_Match::macip_rule() const {
  const ::acl::AccessLists_Acl_Rule_Match_MacIpRule* p = macip_rule_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.Match.macip_rule)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Rule_Match_MacIpRule*>(
      &::acl::_AccessLists_Acl_Rule_Match_MacIpRule_default_instance_);
}
inline ::acl::AccessLists_Acl_Rule_Match_MacIpRule* AccessLists_Acl_Rule_Match::release_macip_rule() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.Match.macip_rule)
  
  ::acl::AccessLists_Acl_Rule_Match_MacIpRule* temp = macip_rule_;
  macip_rule_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Rule_Match_MacIpRule* AccessLists_Acl_Rule_Match::mutable_macip_rule() {
  
  if (macip_rule_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match_MacIpRule>(GetArenaNoVirtual());
    macip_rule_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.Match.macip_rule)
  return macip_rule_;
}
inline void AccessLists_Acl_Rule_Match::set_allocated_macip_rule(::acl::AccessLists_Acl_Rule_Match_MacIpRule* macip_rule) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete macip_rule_;
  }
  if (macip_rule) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      macip_rule = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, macip_rule, submessage_arena);
    }
    
  } else {
    
  }
  macip_rule_ = macip_rule;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.Match.macip_rule)
}

// -------------------------------------------------------------------

// AccessLists_Acl_Rule

// string rule_name = 1;
inline void AccessLists_Acl_Rule::clear_rule_name() {
  rule_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLists_Acl_Rule::rule_name() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.rule_name)
  return rule_name_.GetNoArena();
}
inline void AccessLists_Acl_Rule::set_rule_name(const ::std::string& value) {
  
  rule_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.rule_name)
}
#if LANG_CXX11
inline void AccessLists_Acl_Rule::set_rule_name(::std::string&& value) {
  
  rule_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:acl.AccessLists.Acl.Rule.rule_name)
}
#endif
inline void AccessLists_Acl_Rule::set_rule_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  rule_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:acl.AccessLists.Acl.Rule.rule_name)
}
inline void AccessLists_Acl_Rule::set_rule_name(const char* value, size_t size) {
  
  rule_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:acl.AccessLists.Acl.Rule.rule_name)
}
inline ::std::string* AccessLists_Acl_Rule::mutable_rule_name() {
  
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.rule_name)
  return rule_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLists_Acl_Rule::release_rule_name() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.rule_name)
  
  return rule_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLists_Acl_Rule::set_allocated_rule_name(::std::string* rule_name) {
  if (rule_name != NULL) {
    
  } else {
    
  }
  rule_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rule_name);
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.rule_name)
}

// .acl.AclAction acl_action = 2;
inline void AccessLists_Acl_Rule::clear_acl_action() {
  acl_action_ = 0;
}
inline ::acl::AclAction AccessLists_Acl_Rule::acl_action() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.acl_action)
  return static_cast< ::acl::AclAction >(acl_action_);
}
inline void AccessLists_Acl_Rule::set_acl_action(::acl::AclAction value) {
  
  acl_action_ = value;
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Rule.acl_action)
}

// .acl.AccessLists.Acl.Rule.Match match = 3;
inline bool AccessLists_Acl_Rule::has_match() const {
  return this != internal_default_instance() && match_ != NULL;
}
inline void AccessLists_Acl_Rule::clear_match() {
  if (GetArenaNoVirtual() == NULL && match_ != NULL) {
    delete match_;
  }
  match_ = NULL;
}
inline const ::acl::AccessLists_Acl_Rule_Match& AccessLists_Acl_Rule::_internal_match() const {
  return *match_;
}
inline const ::acl::AccessLists_Acl_Rule_Match& AccessLists_Acl_Rule::match() const {
  const ::acl::AccessLists_Acl_Rule_Match* p = match_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Rule.match)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Rule_Match*>(
      &::acl::_AccessLists_Acl_Rule_Match_default_instance_);
}
inline ::acl::AccessLists_Acl_Rule_Match* AccessLists_Acl_Rule::release_match() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.Rule.match)
  
  ::acl::AccessLists_Acl_Rule_Match* temp = match_;
  match_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Rule_Match* AccessLists_Acl_Rule::mutable_match() {
  
  if (match_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Rule_Match>(GetArenaNoVirtual());
    match_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Rule.match)
  return match_;
}
inline void AccessLists_Acl_Rule::set_allocated_match(::acl::AccessLists_Acl_Rule_Match* match) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete match_;
  }
  if (match) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      match = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, match, submessage_arena);
    }
    
  } else {
    
  }
  match_ = match;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.Rule.match)
}

// -------------------------------------------------------------------

// AccessLists_Acl_Interfaces

// repeated string egress = 1;
inline int AccessLists_Acl_Interfaces::egress_size() const {
  return egress_.size();
}
inline void AccessLists_Acl_Interfaces::clear_egress() {
  egress_.Clear();
}
inline const ::std::string& AccessLists_Acl_Interfaces::egress(int index) const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Interfaces.egress)
  return egress_.Get(index);
}
inline ::std::string* AccessLists_Acl_Interfaces::mutable_egress(int index) {
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Interfaces.egress)
  return egress_.Mutable(index);
}
inline void AccessLists_Acl_Interfaces::set_egress(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Interfaces.egress)
  egress_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AccessLists_Acl_Interfaces::set_egress(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Interfaces.egress)
  egress_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AccessLists_Acl_Interfaces::set_egress(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  egress_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:acl.AccessLists.Acl.Interfaces.egress)
}
inline void AccessLists_Acl_Interfaces::set_egress(int index, const char* value, size_t size) {
  egress_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:acl.AccessLists.Acl.Interfaces.egress)
}
inline ::std::string* AccessLists_Acl_Interfaces::add_egress() {
  // @@protoc_insertion_point(field_add_mutable:acl.AccessLists.Acl.Interfaces.egress)
  return egress_.Add();
}
inline void AccessLists_Acl_Interfaces::add_egress(const ::std::string& value) {
  egress_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:acl.AccessLists.Acl.Interfaces.egress)
}
#if LANG_CXX11
inline void AccessLists_Acl_Interfaces::add_egress(::std::string&& value) {
  egress_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:acl.AccessLists.Acl.Interfaces.egress)
}
#endif
inline void AccessLists_Acl_Interfaces::add_egress(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  egress_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:acl.AccessLists.Acl.Interfaces.egress)
}
inline void AccessLists_Acl_Interfaces::add_egress(const char* value, size_t size) {
  egress_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:acl.AccessLists.Acl.Interfaces.egress)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AccessLists_Acl_Interfaces::egress() const {
  // @@protoc_insertion_point(field_list:acl.AccessLists.Acl.Interfaces.egress)
  return egress_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AccessLists_Acl_Interfaces::mutable_egress() {
  // @@protoc_insertion_point(field_mutable_list:acl.AccessLists.Acl.Interfaces.egress)
  return &egress_;
}

// repeated string ingress = 2;
inline int AccessLists_Acl_Interfaces::ingress_size() const {
  return ingress_.size();
}
inline void AccessLists_Acl_Interfaces::clear_ingress() {
  ingress_.Clear();
}
inline const ::std::string& AccessLists_Acl_Interfaces::ingress(int index) const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.Interfaces.ingress)
  return ingress_.Get(index);
}
inline ::std::string* AccessLists_Acl_Interfaces::mutable_ingress(int index) {
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.Interfaces.ingress)
  return ingress_.Mutable(index);
}
inline void AccessLists_Acl_Interfaces::set_ingress(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Interfaces.ingress)
  ingress_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AccessLists_Acl_Interfaces::set_ingress(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.Interfaces.ingress)
  ingress_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AccessLists_Acl_Interfaces::set_ingress(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ingress_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:acl.AccessLists.Acl.Interfaces.ingress)
}
inline void AccessLists_Acl_Interfaces::set_ingress(int index, const char* value, size_t size) {
  ingress_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:acl.AccessLists.Acl.Interfaces.ingress)
}
inline ::std::string* AccessLists_Acl_Interfaces::add_ingress() {
  // @@protoc_insertion_point(field_add_mutable:acl.AccessLists.Acl.Interfaces.ingress)
  return ingress_.Add();
}
inline void AccessLists_Acl_Interfaces::add_ingress(const ::std::string& value) {
  ingress_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:acl.AccessLists.Acl.Interfaces.ingress)
}
#if LANG_CXX11
inline void AccessLists_Acl_Interfaces::add_ingress(::std::string&& value) {
  ingress_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:acl.AccessLists.Acl.Interfaces.ingress)
}
#endif
inline void AccessLists_Acl_Interfaces::add_ingress(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ingress_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:acl.AccessLists.Acl.Interfaces.ingress)
}
inline void AccessLists_Acl_Interfaces::add_ingress(const char* value, size_t size) {
  ingress_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:acl.AccessLists.Acl.Interfaces.ingress)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AccessLists_Acl_Interfaces::ingress() const {
  // @@protoc_insertion_point(field_list:acl.AccessLists.Acl.Interfaces.ingress)
  return ingress_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AccessLists_Acl_Interfaces::mutable_ingress() {
  // @@protoc_insertion_point(field_mutable_list:acl.AccessLists.Acl.Interfaces.ingress)
  return &ingress_;
}

// -------------------------------------------------------------------

// AccessLists_Acl

// string acl_name = 1;
inline void AccessLists_Acl::clear_acl_name() {
  acl_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLists_Acl::acl_name() const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.acl_name)
  return acl_name_.GetNoArena();
}
inline void AccessLists_Acl::set_acl_name(const ::std::string& value) {
  
  acl_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:acl.AccessLists.Acl.acl_name)
}
#if LANG_CXX11
inline void AccessLists_Acl::set_acl_name(::std::string&& value) {
  
  acl_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:acl.AccessLists.Acl.acl_name)
}
#endif
inline void AccessLists_Acl::set_acl_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  acl_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:acl.AccessLists.Acl.acl_name)
}
inline void AccessLists_Acl::set_acl_name(const char* value, size_t size) {
  
  acl_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:acl.AccessLists.Acl.acl_name)
}
inline ::std::string* AccessLists_Acl::mutable_acl_name() {
  
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.acl_name)
  return acl_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLists_Acl::release_acl_name() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.acl_name)
  
  return acl_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLists_Acl::set_allocated_acl_name(::std::string* acl_name) {
  if (acl_name != NULL) {
    
  } else {
    
  }
  acl_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), acl_name);
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.acl_name)
}

// repeated .acl.AccessLists.Acl.Rule rules = 2;
inline int AccessLists_Acl::rules_size() const {
  return rules_.size();
}
inline void AccessLists_Acl::clear_rules() {
  rules_.Clear();
}
inline ::acl::AccessLists_Acl_Rule* AccessLists_Acl::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.rules)
  return rules_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::acl::AccessLists_Acl_Rule >*
AccessLists_Acl::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:acl.AccessLists.Acl.rules)
  return &rules_;
}
inline const ::acl::AccessLists_Acl_Rule& AccessLists_Acl::rules(int index) const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.rules)
  return rules_.Get(index);
}
inline ::acl::AccessLists_Acl_Rule* AccessLists_Acl::add_rules() {
  // @@protoc_insertion_point(field_add:acl.AccessLists.Acl.rules)
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::acl::AccessLists_Acl_Rule >&
AccessLists_Acl::rules() const {
  // @@protoc_insertion_point(field_list:acl.AccessLists.Acl.rules)
  return rules_;
}

// .acl.AccessLists.Acl.Interfaces interfaces = 3;
inline bool AccessLists_Acl::has_interfaces() const {
  return this != internal_default_instance() && interfaces_ != NULL;
}
inline void AccessLists_Acl::clear_interfaces() {
  if (GetArenaNoVirtual() == NULL && interfaces_ != NULL) {
    delete interfaces_;
  }
  interfaces_ = NULL;
}
inline const ::acl::AccessLists_Acl_Interfaces& AccessLists_Acl::_internal_interfaces() const {
  return *interfaces_;
}
inline const ::acl::AccessLists_Acl_Interfaces& AccessLists_Acl::interfaces() const {
  const ::acl::AccessLists_Acl_Interfaces* p = interfaces_;
  // @@protoc_insertion_point(field_get:acl.AccessLists.Acl.interfaces)
  return p != NULL ? *p : *reinterpret_cast<const ::acl::AccessLists_Acl_Interfaces*>(
      &::acl::_AccessLists_Acl_Interfaces_default_instance_);
}
inline ::acl::AccessLists_Acl_Interfaces* AccessLists_Acl::release_interfaces() {
  // @@protoc_insertion_point(field_release:acl.AccessLists.Acl.interfaces)
  
  ::acl::AccessLists_Acl_Interfaces* temp = interfaces_;
  interfaces_ = NULL;
  return temp;
}
inline ::acl::AccessLists_Acl_Interfaces* AccessLists_Acl::mutable_interfaces() {
  
  if (interfaces_ == NULL) {
    auto* p = CreateMaybeMessage<::acl::AccessLists_Acl_Interfaces>(GetArenaNoVirtual());
    interfaces_ = p;
  }
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.Acl.interfaces)
  return interfaces_;
}
inline void AccessLists_Acl::set_allocated_interfaces(::acl::AccessLists_Acl_Interfaces* interfaces) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete interfaces_;
  }
  if (interfaces) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      interfaces = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, interfaces, submessage_arena);
    }
    
  } else {
    
  }
  interfaces_ = interfaces;
  // @@protoc_insertion_point(field_set_allocated:acl.AccessLists.Acl.interfaces)
}

// -------------------------------------------------------------------

// AccessLists

// repeated .acl.AccessLists.Acl acls = 1;
inline int AccessLists::acls_size() const {
  return acls_.size();
}
inline void AccessLists::clear_acls() {
  acls_.Clear();
}
inline ::acl::AccessLists_Acl* AccessLists::mutable_acls(int index) {
  // @@protoc_insertion_point(field_mutable:acl.AccessLists.acls)
  return acls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::acl::AccessLists_Acl >*
AccessLists::mutable_acls() {
  // @@protoc_insertion_point(field_mutable_list:acl.AccessLists.acls)
  return &acls_;
}
inline const ::acl::AccessLists_Acl& AccessLists::acls(int index) const {
  // @@protoc_insertion_point(field_get:acl.AccessLists.acls)
  return acls_.Get(index);
}
inline ::acl::AccessLists_Acl* AccessLists::add_acls() {
  // @@protoc_insertion_point(field_add:acl.AccessLists.acls)
  return acls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::acl::AccessLists_Acl >&
AccessLists::acls() const {
  // @@protoc_insertion_point(field_list:acl.AccessLists.acls)
  return acls_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace acl

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::acl::AclAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::acl::AclAction>() {
  return ::acl::AclAction_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_vpp_2fmodel_2facl_2facl_2eproto
