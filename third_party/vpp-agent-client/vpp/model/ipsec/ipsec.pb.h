// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vpp/model/ipsec/ipsec.proto

#ifndef PROTOBUF_INCLUDED_vpp_2fmodel_2fipsec_2fipsec_2eproto
#define PROTOBUF_INCLUDED_vpp_2fmodel_2fipsec_2fipsec_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_vpp_2fmodel_2fipsec_2fipsec_2eproto 

namespace protobuf_vpp_2fmodel_2fipsec_2fipsec_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_vpp_2fmodel_2fipsec_2fipsec_2eproto
namespace ipsec {
class ResyncRequest;
class ResyncRequestDefaultTypeInternal;
extern ResyncRequestDefaultTypeInternal _ResyncRequest_default_instance_;
class SecurityAssociations;
class SecurityAssociationsDefaultTypeInternal;
extern SecurityAssociationsDefaultTypeInternal _SecurityAssociations_default_instance_;
class SecurityAssociations_SA;
class SecurityAssociations_SADefaultTypeInternal;
extern SecurityAssociations_SADefaultTypeInternal _SecurityAssociations_SA_default_instance_;
class SecurityPolicyDatabases;
class SecurityPolicyDatabasesDefaultTypeInternal;
extern SecurityPolicyDatabasesDefaultTypeInternal _SecurityPolicyDatabases_default_instance_;
class SecurityPolicyDatabases_SPD;
class SecurityPolicyDatabases_SPDDefaultTypeInternal;
extern SecurityPolicyDatabases_SPDDefaultTypeInternal _SecurityPolicyDatabases_SPD_default_instance_;
class SecurityPolicyDatabases_SPD_Interface;
class SecurityPolicyDatabases_SPD_InterfaceDefaultTypeInternal;
extern SecurityPolicyDatabases_SPD_InterfaceDefaultTypeInternal _SecurityPolicyDatabases_SPD_Interface_default_instance_;
class SecurityPolicyDatabases_SPD_PolicyEntry;
class SecurityPolicyDatabases_SPD_PolicyEntryDefaultTypeInternal;
extern SecurityPolicyDatabases_SPD_PolicyEntryDefaultTypeInternal _SecurityPolicyDatabases_SPD_PolicyEntry_default_instance_;
class TunnelInterfaces;
class TunnelInterfacesDefaultTypeInternal;
extern TunnelInterfacesDefaultTypeInternal _TunnelInterfaces_default_instance_;
class TunnelInterfaces_Tunnel;
class TunnelInterfaces_TunnelDefaultTypeInternal;
extern TunnelInterfaces_TunnelDefaultTypeInternal _TunnelInterfaces_Tunnel_default_instance_;
}  // namespace ipsec
namespace google {
namespace protobuf {
template<> ::ipsec::ResyncRequest* Arena::CreateMaybeMessage<::ipsec::ResyncRequest>(Arena*);
template<> ::ipsec::SecurityAssociations* Arena::CreateMaybeMessage<::ipsec::SecurityAssociations>(Arena*);
template<> ::ipsec::SecurityAssociations_SA* Arena::CreateMaybeMessage<::ipsec::SecurityAssociations_SA>(Arena*);
template<> ::ipsec::SecurityPolicyDatabases* Arena::CreateMaybeMessage<::ipsec::SecurityPolicyDatabases>(Arena*);
template<> ::ipsec::SecurityPolicyDatabases_SPD* Arena::CreateMaybeMessage<::ipsec::SecurityPolicyDatabases_SPD>(Arena*);
template<> ::ipsec::SecurityPolicyDatabases_SPD_Interface* Arena::CreateMaybeMessage<::ipsec::SecurityPolicyDatabases_SPD_Interface>(Arena*);
template<> ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry* Arena::CreateMaybeMessage<::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry>(Arena*);
template<> ::ipsec::TunnelInterfaces* Arena::CreateMaybeMessage<::ipsec::TunnelInterfaces>(Arena*);
template<> ::ipsec::TunnelInterfaces_Tunnel* Arena::CreateMaybeMessage<::ipsec::TunnelInterfaces_Tunnel>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ipsec {

enum SecurityPolicyDatabases_SPD_PolicyEntry_Action {
  SecurityPolicyDatabases_SPD_PolicyEntry_Action_BYPASS = 0,
  SecurityPolicyDatabases_SPD_PolicyEntry_Action_DISCARD = 1,
  SecurityPolicyDatabases_SPD_PolicyEntry_Action_PROTECT = 3,
  SecurityPolicyDatabases_SPD_PolicyEntry_Action_SecurityPolicyDatabases_SPD_PolicyEntry_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SecurityPolicyDatabases_SPD_PolicyEntry_Action_SecurityPolicyDatabases_SPD_PolicyEntry_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SecurityPolicyDatabases_SPD_PolicyEntry_Action_IsValid(int value);
const SecurityPolicyDatabases_SPD_PolicyEntry_Action SecurityPolicyDatabases_SPD_PolicyEntry_Action_Action_MIN = SecurityPolicyDatabases_SPD_PolicyEntry_Action_BYPASS;
const SecurityPolicyDatabases_SPD_PolicyEntry_Action SecurityPolicyDatabases_SPD_PolicyEntry_Action_Action_MAX = SecurityPolicyDatabases_SPD_PolicyEntry_Action_PROTECT;
const int SecurityPolicyDatabases_SPD_PolicyEntry_Action_Action_ARRAYSIZE = SecurityPolicyDatabases_SPD_PolicyEntry_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityPolicyDatabases_SPD_PolicyEntry_Action_descriptor();
inline const ::std::string& SecurityPolicyDatabases_SPD_PolicyEntry_Action_Name(SecurityPolicyDatabases_SPD_PolicyEntry_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityPolicyDatabases_SPD_PolicyEntry_Action_descriptor(), value);
}
inline bool SecurityPolicyDatabases_SPD_PolicyEntry_Action_Parse(
    const ::std::string& name, SecurityPolicyDatabases_SPD_PolicyEntry_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityPolicyDatabases_SPD_PolicyEntry_Action>(
    SecurityPolicyDatabases_SPD_PolicyEntry_Action_descriptor(), name, value);
}
enum SecurityAssociations_SA_IPSecProtocol {
  SecurityAssociations_SA_IPSecProtocol_AH = 0,
  SecurityAssociations_SA_IPSecProtocol_ESP = 1,
  SecurityAssociations_SA_IPSecProtocol_SecurityAssociations_SA_IPSecProtocol_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SecurityAssociations_SA_IPSecProtocol_SecurityAssociations_SA_IPSecProtocol_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SecurityAssociations_SA_IPSecProtocol_IsValid(int value);
const SecurityAssociations_SA_IPSecProtocol SecurityAssociations_SA_IPSecProtocol_IPSecProtocol_MIN = SecurityAssociations_SA_IPSecProtocol_AH;
const SecurityAssociations_SA_IPSecProtocol SecurityAssociations_SA_IPSecProtocol_IPSecProtocol_MAX = SecurityAssociations_SA_IPSecProtocol_ESP;
const int SecurityAssociations_SA_IPSecProtocol_IPSecProtocol_ARRAYSIZE = SecurityAssociations_SA_IPSecProtocol_IPSecProtocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityAssociations_SA_IPSecProtocol_descriptor();
inline const ::std::string& SecurityAssociations_SA_IPSecProtocol_Name(SecurityAssociations_SA_IPSecProtocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityAssociations_SA_IPSecProtocol_descriptor(), value);
}
inline bool SecurityAssociations_SA_IPSecProtocol_Parse(
    const ::std::string& name, SecurityAssociations_SA_IPSecProtocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityAssociations_SA_IPSecProtocol>(
    SecurityAssociations_SA_IPSecProtocol_descriptor(), name, value);
}
enum CryptoAlgorithm {
  NONE_CRYPTO = 0,
  AES_CBC_128 = 1,
  AES_CBC_192 = 2,
  AES_CBC_256 = 3,
  CryptoAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CryptoAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CryptoAlgorithm_IsValid(int value);
const CryptoAlgorithm CryptoAlgorithm_MIN = NONE_CRYPTO;
const CryptoAlgorithm CryptoAlgorithm_MAX = AES_CBC_256;
const int CryptoAlgorithm_ARRAYSIZE = CryptoAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* CryptoAlgorithm_descriptor();
inline const ::std::string& CryptoAlgorithm_Name(CryptoAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    CryptoAlgorithm_descriptor(), value);
}
inline bool CryptoAlgorithm_Parse(
    const ::std::string& name, CryptoAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CryptoAlgorithm>(
    CryptoAlgorithm_descriptor(), name, value);
}
enum IntegAlgorithm {
  NONE_INTEG = 0,
  MD5_96 = 1,
  SHA1_96 = 2,
  SHA_256_96 = 3,
  SHA_256_128 = 4,
  SHA_384_192 = 5,
  SHA_512_256 = 6,
  IntegAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  IntegAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool IntegAlgorithm_IsValid(int value);
const IntegAlgorithm IntegAlgorithm_MIN = NONE_INTEG;
const IntegAlgorithm IntegAlgorithm_MAX = SHA_512_256;
const int IntegAlgorithm_ARRAYSIZE = IntegAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* IntegAlgorithm_descriptor();
inline const ::std::string& IntegAlgorithm_Name(IntegAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    IntegAlgorithm_descriptor(), value);
}
inline bool IntegAlgorithm_Parse(
    const ::std::string& name, IntegAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IntegAlgorithm>(
    IntegAlgorithm_descriptor(), name, value);
}
// ===================================================================

class TunnelInterfaces_Tunnel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ipsec.TunnelInterfaces.Tunnel) */ {
 public:
  TunnelInterfaces_Tunnel();
  virtual ~TunnelInterfaces_Tunnel();

  TunnelInterfaces_Tunnel(const TunnelInterfaces_Tunnel& from);

  inline TunnelInterfaces_Tunnel& operator=(const TunnelInterfaces_Tunnel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TunnelInterfaces_Tunnel(TunnelInterfaces_Tunnel&& from) noexcept
    : TunnelInterfaces_Tunnel() {
    *this = ::std::move(from);
  }

  inline TunnelInterfaces_Tunnel& operator=(TunnelInterfaces_Tunnel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TunnelInterfaces_Tunnel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TunnelInterfaces_Tunnel* internal_default_instance() {
    return reinterpret_cast<const TunnelInterfaces_Tunnel*>(
               &_TunnelInterfaces_Tunnel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TunnelInterfaces_Tunnel* other);
  friend void swap(TunnelInterfaces_Tunnel& a, TunnelInterfaces_Tunnel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TunnelInterfaces_Tunnel* New() const final {
    return CreateMaybeMessage<TunnelInterfaces_Tunnel>(NULL);
  }

  TunnelInterfaces_Tunnel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TunnelInterfaces_Tunnel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TunnelInterfaces_Tunnel& from);
  void MergeFrom(const TunnelInterfaces_Tunnel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TunnelInterfaces_Tunnel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ip_addresses = 101;
  int ip_addresses_size() const;
  void clear_ip_addresses();
  static const int kIpAddressesFieldNumber = 101;
  const ::std::string& ip_addresses(int index) const;
  ::std::string* mutable_ip_addresses(int index);
  void set_ip_addresses(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ip_addresses(int index, ::std::string&& value);
  #endif
  void set_ip_addresses(int index, const char* value);
  void set_ip_addresses(int index, const char* value, size_t size);
  ::std::string* add_ip_addresses();
  void add_ip_addresses(const ::std::string& value);
  #if LANG_CXX11
  void add_ip_addresses(::std::string&& value);
  #endif
  void add_ip_addresses(const char* value);
  void add_ip_addresses(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ip_addresses() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ip_addresses();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string local_ip = 4;
  void clear_local_ip();
  static const int kLocalIpFieldNumber = 4;
  const ::std::string& local_ip() const;
  void set_local_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_local_ip(::std::string&& value);
  #endif
  void set_local_ip(const char* value);
  void set_local_ip(const char* value, size_t size);
  ::std::string* mutable_local_ip();
  ::std::string* release_local_ip();
  void set_allocated_local_ip(::std::string* local_ip);

  // string remote_ip = 5;
  void clear_remote_ip();
  static const int kRemoteIpFieldNumber = 5;
  const ::std::string& remote_ip() const;
  void set_remote_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_ip(::std::string&& value);
  #endif
  void set_remote_ip(const char* value);
  void set_remote_ip(const char* value, size_t size);
  ::std::string* mutable_remote_ip();
  ::std::string* release_remote_ip();
  void set_allocated_remote_ip(::std::string* remote_ip);

  // string local_crypto_key = 9;
  void clear_local_crypto_key();
  static const int kLocalCryptoKeyFieldNumber = 9;
  const ::std::string& local_crypto_key() const;
  void set_local_crypto_key(const ::std::string& value);
  #if LANG_CXX11
  void set_local_crypto_key(::std::string&& value);
  #endif
  void set_local_crypto_key(const char* value);
  void set_local_crypto_key(const char* value, size_t size);
  ::std::string* mutable_local_crypto_key();
  ::std::string* release_local_crypto_key();
  void set_allocated_local_crypto_key(::std::string* local_crypto_key);

  // string remote_crypto_key = 10;
  void clear_remote_crypto_key();
  static const int kRemoteCryptoKeyFieldNumber = 10;
  const ::std::string& remote_crypto_key() const;
  void set_remote_crypto_key(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_crypto_key(::std::string&& value);
  #endif
  void set_remote_crypto_key(const char* value);
  void set_remote_crypto_key(const char* value, size_t size);
  ::std::string* mutable_remote_crypto_key();
  ::std::string* release_remote_crypto_key();
  void set_allocated_remote_crypto_key(::std::string* remote_crypto_key);

  // string local_integ_key = 12;
  void clear_local_integ_key();
  static const int kLocalIntegKeyFieldNumber = 12;
  const ::std::string& local_integ_key() const;
  void set_local_integ_key(const ::std::string& value);
  #if LANG_CXX11
  void set_local_integ_key(::std::string&& value);
  #endif
  void set_local_integ_key(const char* value);
  void set_local_integ_key(const char* value, size_t size);
  ::std::string* mutable_local_integ_key();
  ::std::string* release_local_integ_key();
  void set_allocated_local_integ_key(::std::string* local_integ_key);

  // string remote_integ_key = 13;
  void clear_remote_integ_key();
  static const int kRemoteIntegKeyFieldNumber = 13;
  const ::std::string& remote_integ_key() const;
  void set_remote_integ_key(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_integ_key(::std::string&& value);
  #endif
  void set_remote_integ_key(const char* value);
  void set_remote_integ_key(const char* value, size_t size);
  ::std::string* mutable_remote_integ_key();
  ::std::string* release_remote_integ_key();
  void set_allocated_remote_integ_key(::std::string* remote_integ_key);

  // string unnumbered_name = 103;
  void clear_unnumbered_name();
  static const int kUnnumberedNameFieldNumber = 103;
  const ::std::string& unnumbered_name() const;
  void set_unnumbered_name(const ::std::string& value);
  #if LANG_CXX11
  void set_unnumbered_name(::std::string&& value);
  #endif
  void set_unnumbered_name(const char* value);
  void set_unnumbered_name(const char* value, size_t size);
  ::std::string* mutable_unnumbered_name();
  ::std::string* release_unnumbered_name();
  void set_allocated_unnumbered_name(::std::string* unnumbered_name);

  // uint32 local_spi = 6;
  void clear_local_spi();
  static const int kLocalSpiFieldNumber = 6;
  ::google::protobuf::uint32 local_spi() const;
  void set_local_spi(::google::protobuf::uint32 value);

  // uint32 remote_spi = 7;
  void clear_remote_spi();
  static const int kRemoteSpiFieldNumber = 7;
  ::google::protobuf::uint32 remote_spi() const;
  void set_remote_spi(::google::protobuf::uint32 value);

  // .ipsec.CryptoAlgorithm crypto_alg = 8;
  void clear_crypto_alg();
  static const int kCryptoAlgFieldNumber = 8;
  ::ipsec::CryptoAlgorithm crypto_alg() const;
  void set_crypto_alg(::ipsec::CryptoAlgorithm value);

  // .ipsec.IntegAlgorithm integ_alg = 11;
  void clear_integ_alg();
  static const int kIntegAlgFieldNumber = 11;
  ::ipsec::IntegAlgorithm integ_alg() const;
  void set_integ_alg(::ipsec::IntegAlgorithm value);

  // bool esn = 2;
  void clear_esn();
  static const int kEsnFieldNumber = 2;
  bool esn() const;
  void set_esn(bool value);

  // bool anti_replay = 3;
  void clear_anti_replay();
  static const int kAntiReplayFieldNumber = 3;
  bool anti_replay() const;
  void set_anti_replay(bool value);

  // bool enabled = 100;
  void clear_enabled();
  static const int kEnabledFieldNumber = 100;
  bool enabled() const;
  void set_enabled(bool value);

  // uint32 vrf = 102;
  void clear_vrf();
  static const int kVrfFieldNumber = 102;
  ::google::protobuf::uint32 vrf() const;
  void set_vrf(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ipsec.TunnelInterfaces.Tunnel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ip_addresses_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr local_ip_;
  ::google::protobuf::internal::ArenaStringPtr remote_ip_;
  ::google::protobuf::internal::ArenaStringPtr local_crypto_key_;
  ::google::protobuf::internal::ArenaStringPtr remote_crypto_key_;
  ::google::protobuf::internal::ArenaStringPtr local_integ_key_;
  ::google::protobuf::internal::ArenaStringPtr remote_integ_key_;
  ::google::protobuf::internal::ArenaStringPtr unnumbered_name_;
  ::google::protobuf::uint32 local_spi_;
  ::google::protobuf::uint32 remote_spi_;
  int crypto_alg_;
  int integ_alg_;
  bool esn_;
  bool anti_replay_;
  bool enabled_;
  ::google::protobuf::uint32 vrf_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2fipsec_2fipsec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TunnelInterfaces : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ipsec.TunnelInterfaces) */ {
 public:
  TunnelInterfaces();
  virtual ~TunnelInterfaces();

  TunnelInterfaces(const TunnelInterfaces& from);

  inline TunnelInterfaces& operator=(const TunnelInterfaces& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TunnelInterfaces(TunnelInterfaces&& from) noexcept
    : TunnelInterfaces() {
    *this = ::std::move(from);
  }

  inline TunnelInterfaces& operator=(TunnelInterfaces&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TunnelInterfaces& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TunnelInterfaces* internal_default_instance() {
    return reinterpret_cast<const TunnelInterfaces*>(
               &_TunnelInterfaces_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TunnelInterfaces* other);
  friend void swap(TunnelInterfaces& a, TunnelInterfaces& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TunnelInterfaces* New() const final {
    return CreateMaybeMessage<TunnelInterfaces>(NULL);
  }

  TunnelInterfaces* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TunnelInterfaces>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TunnelInterfaces& from);
  void MergeFrom(const TunnelInterfaces& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TunnelInterfaces* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TunnelInterfaces_Tunnel Tunnel;

  // accessors -------------------------------------------------------

  // repeated .ipsec.TunnelInterfaces.Tunnel tunnels = 1;
  int tunnels_size() const;
  void clear_tunnels();
  static const int kTunnelsFieldNumber = 1;
  ::ipsec::TunnelInterfaces_Tunnel* mutable_tunnels(int index);
  ::google::protobuf::RepeatedPtrField< ::ipsec::TunnelInterfaces_Tunnel >*
      mutable_tunnels();
  const ::ipsec::TunnelInterfaces_Tunnel& tunnels(int index) const;
  ::ipsec::TunnelInterfaces_Tunnel* add_tunnels();
  const ::google::protobuf::RepeatedPtrField< ::ipsec::TunnelInterfaces_Tunnel >&
      tunnels() const;

  // @@protoc_insertion_point(class_scope:ipsec.TunnelInterfaces)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ipsec::TunnelInterfaces_Tunnel > tunnels_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2fipsec_2fipsec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SecurityPolicyDatabases_SPD_Interface : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ipsec.SecurityPolicyDatabases.SPD.Interface) */ {
 public:
  SecurityPolicyDatabases_SPD_Interface();
  virtual ~SecurityPolicyDatabases_SPD_Interface();

  SecurityPolicyDatabases_SPD_Interface(const SecurityPolicyDatabases_SPD_Interface& from);

  inline SecurityPolicyDatabases_SPD_Interface& operator=(const SecurityPolicyDatabases_SPD_Interface& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SecurityPolicyDatabases_SPD_Interface(SecurityPolicyDatabases_SPD_Interface&& from) noexcept
    : SecurityPolicyDatabases_SPD_Interface() {
    *this = ::std::move(from);
  }

  inline SecurityPolicyDatabases_SPD_Interface& operator=(SecurityPolicyDatabases_SPD_Interface&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityPolicyDatabases_SPD_Interface& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SecurityPolicyDatabases_SPD_Interface* internal_default_instance() {
    return reinterpret_cast<const SecurityPolicyDatabases_SPD_Interface*>(
               &_SecurityPolicyDatabases_SPD_Interface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SecurityPolicyDatabases_SPD_Interface* other);
  friend void swap(SecurityPolicyDatabases_SPD_Interface& a, SecurityPolicyDatabases_SPD_Interface& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SecurityPolicyDatabases_SPD_Interface* New() const final {
    return CreateMaybeMessage<SecurityPolicyDatabases_SPD_Interface>(NULL);
  }

  SecurityPolicyDatabases_SPD_Interface* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SecurityPolicyDatabases_SPD_Interface>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SecurityPolicyDatabases_SPD_Interface& from);
  void MergeFrom(const SecurityPolicyDatabases_SPD_Interface& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityPolicyDatabases_SPD_Interface* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:ipsec.SecurityPolicyDatabases.SPD.Interface)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2fipsec_2fipsec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SecurityPolicyDatabases_SPD_PolicyEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry) */ {
 public:
  SecurityPolicyDatabases_SPD_PolicyEntry();
  virtual ~SecurityPolicyDatabases_SPD_PolicyEntry();

  SecurityPolicyDatabases_SPD_PolicyEntry(const SecurityPolicyDatabases_SPD_PolicyEntry& from);

  inline SecurityPolicyDatabases_SPD_PolicyEntry& operator=(const SecurityPolicyDatabases_SPD_PolicyEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SecurityPolicyDatabases_SPD_PolicyEntry(SecurityPolicyDatabases_SPD_PolicyEntry&& from) noexcept
    : SecurityPolicyDatabases_SPD_PolicyEntry() {
    *this = ::std::move(from);
  }

  inline SecurityPolicyDatabases_SPD_PolicyEntry& operator=(SecurityPolicyDatabases_SPD_PolicyEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityPolicyDatabases_SPD_PolicyEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SecurityPolicyDatabases_SPD_PolicyEntry* internal_default_instance() {
    return reinterpret_cast<const SecurityPolicyDatabases_SPD_PolicyEntry*>(
               &_SecurityPolicyDatabases_SPD_PolicyEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SecurityPolicyDatabases_SPD_PolicyEntry* other);
  friend void swap(SecurityPolicyDatabases_SPD_PolicyEntry& a, SecurityPolicyDatabases_SPD_PolicyEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SecurityPolicyDatabases_SPD_PolicyEntry* New() const final {
    return CreateMaybeMessage<SecurityPolicyDatabases_SPD_PolicyEntry>(NULL);
  }

  SecurityPolicyDatabases_SPD_PolicyEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SecurityPolicyDatabases_SPD_PolicyEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SecurityPolicyDatabases_SPD_PolicyEntry& from);
  void MergeFrom(const SecurityPolicyDatabases_SPD_PolicyEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityPolicyDatabases_SPD_PolicyEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SecurityPolicyDatabases_SPD_PolicyEntry_Action Action;
  static const Action BYPASS =
    SecurityPolicyDatabases_SPD_PolicyEntry_Action_BYPASS;
  static const Action DISCARD =
    SecurityPolicyDatabases_SPD_PolicyEntry_Action_DISCARD;
  static const Action PROTECT =
    SecurityPolicyDatabases_SPD_PolicyEntry_Action_PROTECT;
  static inline bool Action_IsValid(int value) {
    return SecurityPolicyDatabases_SPD_PolicyEntry_Action_IsValid(value);
  }
  static const Action Action_MIN =
    SecurityPolicyDatabases_SPD_PolicyEntry_Action_Action_MIN;
  static const Action Action_MAX =
    SecurityPolicyDatabases_SPD_PolicyEntry_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    SecurityPolicyDatabases_SPD_PolicyEntry_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return SecurityPolicyDatabases_SPD_PolicyEntry_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return SecurityPolicyDatabases_SPD_PolicyEntry_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return SecurityPolicyDatabases_SPD_PolicyEntry_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string sa = 1;
  void clear_sa();
  static const int kSaFieldNumber = 1;
  const ::std::string& sa() const;
  void set_sa(const ::std::string& value);
  #if LANG_CXX11
  void set_sa(::std::string&& value);
  #endif
  void set_sa(const char* value);
  void set_sa(const char* value, size_t size);
  ::std::string* mutable_sa();
  ::std::string* release_sa();
  void set_allocated_sa(::std::string* sa);

  // string remote_addr_start = 4;
  void clear_remote_addr_start();
  static const int kRemoteAddrStartFieldNumber = 4;
  const ::std::string& remote_addr_start() const;
  void set_remote_addr_start(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_addr_start(::std::string&& value);
  #endif
  void set_remote_addr_start(const char* value);
  void set_remote_addr_start(const char* value, size_t size);
  ::std::string* mutable_remote_addr_start();
  ::std::string* release_remote_addr_start();
  void set_allocated_remote_addr_start(::std::string* remote_addr_start);

  // string remote_addr_stop = 5;
  void clear_remote_addr_stop();
  static const int kRemoteAddrStopFieldNumber = 5;
  const ::std::string& remote_addr_stop() const;
  void set_remote_addr_stop(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_addr_stop(::std::string&& value);
  #endif
  void set_remote_addr_stop(const char* value);
  void set_remote_addr_stop(const char* value, size_t size);
  ::std::string* mutable_remote_addr_stop();
  ::std::string* release_remote_addr_stop();
  void set_allocated_remote_addr_stop(::std::string* remote_addr_stop);

  // string local_addr_start = 6;
  void clear_local_addr_start();
  static const int kLocalAddrStartFieldNumber = 6;
  const ::std::string& local_addr_start() const;
  void set_local_addr_start(const ::std::string& value);
  #if LANG_CXX11
  void set_local_addr_start(::std::string&& value);
  #endif
  void set_local_addr_start(const char* value);
  void set_local_addr_start(const char* value, size_t size);
  ::std::string* mutable_local_addr_start();
  ::std::string* release_local_addr_start();
  void set_allocated_local_addr_start(::std::string* local_addr_start);

  // string local_addr_stop = 7;
  void clear_local_addr_stop();
  static const int kLocalAddrStopFieldNumber = 7;
  const ::std::string& local_addr_stop() const;
  void set_local_addr_stop(const ::std::string& value);
  #if LANG_CXX11
  void set_local_addr_stop(::std::string&& value);
  #endif
  void set_local_addr_stop(const char* value);
  void set_local_addr_stop(const char* value, size_t size);
  ::std::string* mutable_local_addr_stop();
  ::std::string* release_local_addr_stop();
  void set_allocated_local_addr_stop(::std::string* local_addr_stop);

  // int32 priority = 2;
  void clear_priority();
  static const int kPriorityFieldNumber = 2;
  ::google::protobuf::int32 priority() const;
  void set_priority(::google::protobuf::int32 value);

  // bool is_outbound = 3;
  void clear_is_outbound();
  static const int kIsOutboundFieldNumber = 3;
  bool is_outbound() const;
  void set_is_outbound(bool value);

  // uint32 protocol = 8;
  void clear_protocol();
  static const int kProtocolFieldNumber = 8;
  ::google::protobuf::uint32 protocol() const;
  void set_protocol(::google::protobuf::uint32 value);

  // uint32 remote_port_start = 9;
  void clear_remote_port_start();
  static const int kRemotePortStartFieldNumber = 9;
  ::google::protobuf::uint32 remote_port_start() const;
  void set_remote_port_start(::google::protobuf::uint32 value);

  // uint32 remote_port_stop = 10;
  void clear_remote_port_stop();
  static const int kRemotePortStopFieldNumber = 10;
  ::google::protobuf::uint32 remote_port_stop() const;
  void set_remote_port_stop(::google::protobuf::uint32 value);

  // uint32 local_port_start = 11;
  void clear_local_port_start();
  static const int kLocalPortStartFieldNumber = 11;
  ::google::protobuf::uint32 local_port_start() const;
  void set_local_port_start(::google::protobuf::uint32 value);

  // uint32 local_port_stop = 12;
  void clear_local_port_stop();
  static const int kLocalPortStopFieldNumber = 12;
  ::google::protobuf::uint32 local_port_stop() const;
  void set_local_port_stop(::google::protobuf::uint32 value);

  // .ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.Action action = 13;
  void clear_action();
  static const int kActionFieldNumber = 13;
  ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry_Action action() const;
  void set_action(::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry_Action value);

  // @@protoc_insertion_point(class_scope:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sa_;
  ::google::protobuf::internal::ArenaStringPtr remote_addr_start_;
  ::google::protobuf::internal::ArenaStringPtr remote_addr_stop_;
  ::google::protobuf::internal::ArenaStringPtr local_addr_start_;
  ::google::protobuf::internal::ArenaStringPtr local_addr_stop_;
  ::google::protobuf::int32 priority_;
  bool is_outbound_;
  ::google::protobuf::uint32 protocol_;
  ::google::protobuf::uint32 remote_port_start_;
  ::google::protobuf::uint32 remote_port_stop_;
  ::google::protobuf::uint32 local_port_start_;
  ::google::protobuf::uint32 local_port_stop_;
  int action_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2fipsec_2fipsec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SecurityPolicyDatabases_SPD : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ipsec.SecurityPolicyDatabases.SPD) */ {
 public:
  SecurityPolicyDatabases_SPD();
  virtual ~SecurityPolicyDatabases_SPD();

  SecurityPolicyDatabases_SPD(const SecurityPolicyDatabases_SPD& from);

  inline SecurityPolicyDatabases_SPD& operator=(const SecurityPolicyDatabases_SPD& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SecurityPolicyDatabases_SPD(SecurityPolicyDatabases_SPD&& from) noexcept
    : SecurityPolicyDatabases_SPD() {
    *this = ::std::move(from);
  }

  inline SecurityPolicyDatabases_SPD& operator=(SecurityPolicyDatabases_SPD&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityPolicyDatabases_SPD& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SecurityPolicyDatabases_SPD* internal_default_instance() {
    return reinterpret_cast<const SecurityPolicyDatabases_SPD*>(
               &_SecurityPolicyDatabases_SPD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SecurityPolicyDatabases_SPD* other);
  friend void swap(SecurityPolicyDatabases_SPD& a, SecurityPolicyDatabases_SPD& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SecurityPolicyDatabases_SPD* New() const final {
    return CreateMaybeMessage<SecurityPolicyDatabases_SPD>(NULL);
  }

  SecurityPolicyDatabases_SPD* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SecurityPolicyDatabases_SPD>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SecurityPolicyDatabases_SPD& from);
  void MergeFrom(const SecurityPolicyDatabases_SPD& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityPolicyDatabases_SPD* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SecurityPolicyDatabases_SPD_Interface Interface;
  typedef SecurityPolicyDatabases_SPD_PolicyEntry PolicyEntry;

  // accessors -------------------------------------------------------

  // repeated .ipsec.SecurityPolicyDatabases.SPD.Interface interfaces = 2;
  int interfaces_size() const;
  void clear_interfaces();
  static const int kInterfacesFieldNumber = 2;
  ::ipsec::SecurityPolicyDatabases_SPD_Interface* mutable_interfaces(int index);
  ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD_Interface >*
      mutable_interfaces();
  const ::ipsec::SecurityPolicyDatabases_SPD_Interface& interfaces(int index) const;
  ::ipsec::SecurityPolicyDatabases_SPD_Interface* add_interfaces();
  const ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD_Interface >&
      interfaces() const;

  // repeated .ipsec.SecurityPolicyDatabases.SPD.PolicyEntry policy_entries = 3;
  int policy_entries_size() const;
  void clear_policy_entries();
  static const int kPolicyEntriesFieldNumber = 3;
  ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry* mutable_policy_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry >*
      mutable_policy_entries();
  const ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry& policy_entries(int index) const;
  ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry* add_policy_entries();
  const ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry >&
      policy_entries() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:ipsec.SecurityPolicyDatabases.SPD)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD_Interface > interfaces_;
  ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry > policy_entries_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2fipsec_2fipsec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SecurityPolicyDatabases : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ipsec.SecurityPolicyDatabases) */ {
 public:
  SecurityPolicyDatabases();
  virtual ~SecurityPolicyDatabases();

  SecurityPolicyDatabases(const SecurityPolicyDatabases& from);

  inline SecurityPolicyDatabases& operator=(const SecurityPolicyDatabases& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SecurityPolicyDatabases(SecurityPolicyDatabases&& from) noexcept
    : SecurityPolicyDatabases() {
    *this = ::std::move(from);
  }

  inline SecurityPolicyDatabases& operator=(SecurityPolicyDatabases&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityPolicyDatabases& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SecurityPolicyDatabases* internal_default_instance() {
    return reinterpret_cast<const SecurityPolicyDatabases*>(
               &_SecurityPolicyDatabases_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SecurityPolicyDatabases* other);
  friend void swap(SecurityPolicyDatabases& a, SecurityPolicyDatabases& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SecurityPolicyDatabases* New() const final {
    return CreateMaybeMessage<SecurityPolicyDatabases>(NULL);
  }

  SecurityPolicyDatabases* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SecurityPolicyDatabases>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SecurityPolicyDatabases& from);
  void MergeFrom(const SecurityPolicyDatabases& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityPolicyDatabases* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SecurityPolicyDatabases_SPD SPD;

  // accessors -------------------------------------------------------

  // repeated .ipsec.SecurityPolicyDatabases.SPD spds = 1;
  int spds_size() const;
  void clear_spds();
  static const int kSpdsFieldNumber = 1;
  ::ipsec::SecurityPolicyDatabases_SPD* mutable_spds(int index);
  ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD >*
      mutable_spds();
  const ::ipsec::SecurityPolicyDatabases_SPD& spds(int index) const;
  ::ipsec::SecurityPolicyDatabases_SPD* add_spds();
  const ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD >&
      spds() const;

  // @@protoc_insertion_point(class_scope:ipsec.SecurityPolicyDatabases)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD > spds_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2fipsec_2fipsec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SecurityAssociations_SA : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ipsec.SecurityAssociations.SA) */ {
 public:
  SecurityAssociations_SA();
  virtual ~SecurityAssociations_SA();

  SecurityAssociations_SA(const SecurityAssociations_SA& from);

  inline SecurityAssociations_SA& operator=(const SecurityAssociations_SA& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SecurityAssociations_SA(SecurityAssociations_SA&& from) noexcept
    : SecurityAssociations_SA() {
    *this = ::std::move(from);
  }

  inline SecurityAssociations_SA& operator=(SecurityAssociations_SA&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityAssociations_SA& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SecurityAssociations_SA* internal_default_instance() {
    return reinterpret_cast<const SecurityAssociations_SA*>(
               &_SecurityAssociations_SA_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SecurityAssociations_SA* other);
  friend void swap(SecurityAssociations_SA& a, SecurityAssociations_SA& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SecurityAssociations_SA* New() const final {
    return CreateMaybeMessage<SecurityAssociations_SA>(NULL);
  }

  SecurityAssociations_SA* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SecurityAssociations_SA>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SecurityAssociations_SA& from);
  void MergeFrom(const SecurityAssociations_SA& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityAssociations_SA* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SecurityAssociations_SA_IPSecProtocol IPSecProtocol;
  static const IPSecProtocol AH =
    SecurityAssociations_SA_IPSecProtocol_AH;
  static const IPSecProtocol ESP =
    SecurityAssociations_SA_IPSecProtocol_ESP;
  static inline bool IPSecProtocol_IsValid(int value) {
    return SecurityAssociations_SA_IPSecProtocol_IsValid(value);
  }
  static const IPSecProtocol IPSecProtocol_MIN =
    SecurityAssociations_SA_IPSecProtocol_IPSecProtocol_MIN;
  static const IPSecProtocol IPSecProtocol_MAX =
    SecurityAssociations_SA_IPSecProtocol_IPSecProtocol_MAX;
  static const int IPSecProtocol_ARRAYSIZE =
    SecurityAssociations_SA_IPSecProtocol_IPSecProtocol_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IPSecProtocol_descriptor() {
    return SecurityAssociations_SA_IPSecProtocol_descriptor();
  }
  static inline const ::std::string& IPSecProtocol_Name(IPSecProtocol value) {
    return SecurityAssociations_SA_IPSecProtocol_Name(value);
  }
  static inline bool IPSecProtocol_Parse(const ::std::string& name,
      IPSecProtocol* value) {
    return SecurityAssociations_SA_IPSecProtocol_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string crypto_key = 5;
  void clear_crypto_key();
  static const int kCryptoKeyFieldNumber = 5;
  const ::std::string& crypto_key() const;
  void set_crypto_key(const ::std::string& value);
  #if LANG_CXX11
  void set_crypto_key(::std::string&& value);
  #endif
  void set_crypto_key(const char* value);
  void set_crypto_key(const char* value, size_t size);
  ::std::string* mutable_crypto_key();
  ::std::string* release_crypto_key();
  void set_allocated_crypto_key(::std::string* crypto_key);

  // string integ_key = 7;
  void clear_integ_key();
  static const int kIntegKeyFieldNumber = 7;
  const ::std::string& integ_key() const;
  void set_integ_key(const ::std::string& value);
  #if LANG_CXX11
  void set_integ_key(::std::string&& value);
  #endif
  void set_integ_key(const char* value);
  void set_integ_key(const char* value, size_t size);
  ::std::string* mutable_integ_key();
  ::std::string* release_integ_key();
  void set_allocated_integ_key(::std::string* integ_key);

  // string tunnel_src_addr = 10;
  void clear_tunnel_src_addr();
  static const int kTunnelSrcAddrFieldNumber = 10;
  const ::std::string& tunnel_src_addr() const;
  void set_tunnel_src_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_tunnel_src_addr(::std::string&& value);
  #endif
  void set_tunnel_src_addr(const char* value);
  void set_tunnel_src_addr(const char* value, size_t size);
  ::std::string* mutable_tunnel_src_addr();
  ::std::string* release_tunnel_src_addr();
  void set_allocated_tunnel_src_addr(::std::string* tunnel_src_addr);

  // string tunnel_dst_addr = 11;
  void clear_tunnel_dst_addr();
  static const int kTunnelDstAddrFieldNumber = 11;
  const ::std::string& tunnel_dst_addr() const;
  void set_tunnel_dst_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_tunnel_dst_addr(::std::string&& value);
  #endif
  void set_tunnel_dst_addr(const char* value);
  void set_tunnel_dst_addr(const char* value, size_t size);
  ::std::string* mutable_tunnel_dst_addr();
  ::std::string* release_tunnel_dst_addr();
  void set_allocated_tunnel_dst_addr(::std::string* tunnel_dst_addr);

  // uint32 spi = 2;
  void clear_spi();
  static const int kSpiFieldNumber = 2;
  ::google::protobuf::uint32 spi() const;
  void set_spi(::google::protobuf::uint32 value);

  // .ipsec.SecurityAssociations.SA.IPSecProtocol protocol = 3;
  void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  ::ipsec::SecurityAssociations_SA_IPSecProtocol protocol() const;
  void set_protocol(::ipsec::SecurityAssociations_SA_IPSecProtocol value);

  // .ipsec.CryptoAlgorithm crypto_alg = 4;
  void clear_crypto_alg();
  static const int kCryptoAlgFieldNumber = 4;
  ::ipsec::CryptoAlgorithm crypto_alg() const;
  void set_crypto_alg(::ipsec::CryptoAlgorithm value);

  // .ipsec.IntegAlgorithm integ_alg = 6;
  void clear_integ_alg();
  static const int kIntegAlgFieldNumber = 6;
  ::ipsec::IntegAlgorithm integ_alg() const;
  void set_integ_alg(::ipsec::IntegAlgorithm value);

  // bool use_esn = 8;
  void clear_use_esn();
  static const int kUseEsnFieldNumber = 8;
  bool use_esn() const;
  void set_use_esn(bool value);

  // bool use_anti_replay = 9;
  void clear_use_anti_replay();
  static const int kUseAntiReplayFieldNumber = 9;
  bool use_anti_replay() const;
  void set_use_anti_replay(bool value);

  // bool enable_udp_encap = 12;
  void clear_enable_udp_encap();
  static const int kEnableUdpEncapFieldNumber = 12;
  bool enable_udp_encap() const;
  void set_enable_udp_encap(bool value);

  // @@protoc_insertion_point(class_scope:ipsec.SecurityAssociations.SA)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr crypto_key_;
  ::google::protobuf::internal::ArenaStringPtr integ_key_;
  ::google::protobuf::internal::ArenaStringPtr tunnel_src_addr_;
  ::google::protobuf::internal::ArenaStringPtr tunnel_dst_addr_;
  ::google::protobuf::uint32 spi_;
  int protocol_;
  int crypto_alg_;
  int integ_alg_;
  bool use_esn_;
  bool use_anti_replay_;
  bool enable_udp_encap_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2fipsec_2fipsec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SecurityAssociations : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ipsec.SecurityAssociations) */ {
 public:
  SecurityAssociations();
  virtual ~SecurityAssociations();

  SecurityAssociations(const SecurityAssociations& from);

  inline SecurityAssociations& operator=(const SecurityAssociations& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SecurityAssociations(SecurityAssociations&& from) noexcept
    : SecurityAssociations() {
    *this = ::std::move(from);
  }

  inline SecurityAssociations& operator=(SecurityAssociations&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityAssociations& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SecurityAssociations* internal_default_instance() {
    return reinterpret_cast<const SecurityAssociations*>(
               &_SecurityAssociations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SecurityAssociations* other);
  friend void swap(SecurityAssociations& a, SecurityAssociations& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SecurityAssociations* New() const final {
    return CreateMaybeMessage<SecurityAssociations>(NULL);
  }

  SecurityAssociations* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SecurityAssociations>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SecurityAssociations& from);
  void MergeFrom(const SecurityAssociations& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityAssociations* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SecurityAssociations_SA SA;

  // accessors -------------------------------------------------------

  // repeated .ipsec.SecurityAssociations.SA sas = 1;
  int sas_size() const;
  void clear_sas();
  static const int kSasFieldNumber = 1;
  ::ipsec::SecurityAssociations_SA* mutable_sas(int index);
  ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityAssociations_SA >*
      mutable_sas();
  const ::ipsec::SecurityAssociations_SA& sas(int index) const;
  ::ipsec::SecurityAssociations_SA* add_sas();
  const ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityAssociations_SA >&
      sas() const;

  // @@protoc_insertion_point(class_scope:ipsec.SecurityAssociations)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityAssociations_SA > sas_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2fipsec_2fipsec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResyncRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ipsec.ResyncRequest) */ {
 public:
  ResyncRequest();
  virtual ~ResyncRequest();

  ResyncRequest(const ResyncRequest& from);

  inline ResyncRequest& operator=(const ResyncRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResyncRequest(ResyncRequest&& from) noexcept
    : ResyncRequest() {
    *this = ::std::move(from);
  }

  inline ResyncRequest& operator=(ResyncRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResyncRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResyncRequest* internal_default_instance() {
    return reinterpret_cast<const ResyncRequest*>(
               &_ResyncRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ResyncRequest* other);
  friend void swap(ResyncRequest& a, ResyncRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResyncRequest* New() const final {
    return CreateMaybeMessage<ResyncRequest>(NULL);
  }

  ResyncRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResyncRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResyncRequest& from);
  void MergeFrom(const ResyncRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResyncRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ipsec.TunnelInterfaces.Tunnel tunnels = 1;
  int tunnels_size() const;
  void clear_tunnels();
  static const int kTunnelsFieldNumber = 1;
  ::ipsec::TunnelInterfaces_Tunnel* mutable_tunnels(int index);
  ::google::protobuf::RepeatedPtrField< ::ipsec::TunnelInterfaces_Tunnel >*
      mutable_tunnels();
  const ::ipsec::TunnelInterfaces_Tunnel& tunnels(int index) const;
  ::ipsec::TunnelInterfaces_Tunnel* add_tunnels();
  const ::google::protobuf::RepeatedPtrField< ::ipsec::TunnelInterfaces_Tunnel >&
      tunnels() const;

  // repeated .ipsec.SecurityPolicyDatabases.SPD spds = 2;
  int spds_size() const;
  void clear_spds();
  static const int kSpdsFieldNumber = 2;
  ::ipsec::SecurityPolicyDatabases_SPD* mutable_spds(int index);
  ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD >*
      mutable_spds();
  const ::ipsec::SecurityPolicyDatabases_SPD& spds(int index) const;
  ::ipsec::SecurityPolicyDatabases_SPD* add_spds();
  const ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD >&
      spds() const;

  // repeated .ipsec.SecurityAssociations.SA sas = 3;
  int sas_size() const;
  void clear_sas();
  static const int kSasFieldNumber = 3;
  ::ipsec::SecurityAssociations_SA* mutable_sas(int index);
  ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityAssociations_SA >*
      mutable_sas();
  const ::ipsec::SecurityAssociations_SA& sas(int index) const;
  ::ipsec::SecurityAssociations_SA* add_sas();
  const ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityAssociations_SA >&
      sas() const;

  // @@protoc_insertion_point(class_scope:ipsec.ResyncRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ipsec::TunnelInterfaces_Tunnel > tunnels_;
  ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD > spds_;
  ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityAssociations_SA > sas_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vpp_2fmodel_2fipsec_2fipsec_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TunnelInterfaces_Tunnel

// string name = 1;
inline void TunnelInterfaces_Tunnel::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelInterfaces_Tunnel::name() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.name)
  return name_.GetNoArena();
}
inline void TunnelInterfaces_Tunnel::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.name)
}
#if LANG_CXX11
inline void TunnelInterfaces_Tunnel::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.TunnelInterfaces.Tunnel.name)
}
#endif
inline void TunnelInterfaces_Tunnel::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.TunnelInterfaces.Tunnel.name)
}
inline void TunnelInterfaces_Tunnel::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.TunnelInterfaces.Tunnel.name)
}
inline ::std::string* TunnelInterfaces_Tunnel::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.TunnelInterfaces.Tunnel.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelInterfaces_Tunnel::release_name() {
  // @@protoc_insertion_point(field_release:ipsec.TunnelInterfaces.Tunnel.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelInterfaces_Tunnel::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ipsec.TunnelInterfaces.Tunnel.name)
}

// bool esn = 2;
inline void TunnelInterfaces_Tunnel::clear_esn() {
  esn_ = false;
}
inline bool TunnelInterfaces_Tunnel::esn() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.esn)
  return esn_;
}
inline void TunnelInterfaces_Tunnel::set_esn(bool value) {
  
  esn_ = value;
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.esn)
}

// bool anti_replay = 3;
inline void TunnelInterfaces_Tunnel::clear_anti_replay() {
  anti_replay_ = false;
}
inline bool TunnelInterfaces_Tunnel::anti_replay() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.anti_replay)
  return anti_replay_;
}
inline void TunnelInterfaces_Tunnel::set_anti_replay(bool value) {
  
  anti_replay_ = value;
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.anti_replay)
}

// string local_ip = 4;
inline void TunnelInterfaces_Tunnel::clear_local_ip() {
  local_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelInterfaces_Tunnel::local_ip() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.local_ip)
  return local_ip_.GetNoArena();
}
inline void TunnelInterfaces_Tunnel::set_local_ip(const ::std::string& value) {
  
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.local_ip)
}
#if LANG_CXX11
inline void TunnelInterfaces_Tunnel::set_local_ip(::std::string&& value) {
  
  local_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.TunnelInterfaces.Tunnel.local_ip)
}
#endif
inline void TunnelInterfaces_Tunnel::set_local_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.TunnelInterfaces.Tunnel.local_ip)
}
inline void TunnelInterfaces_Tunnel::set_local_ip(const char* value, size_t size) {
  
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.TunnelInterfaces.Tunnel.local_ip)
}
inline ::std::string* TunnelInterfaces_Tunnel::mutable_local_ip() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.TunnelInterfaces.Tunnel.local_ip)
  return local_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelInterfaces_Tunnel::release_local_ip() {
  // @@protoc_insertion_point(field_release:ipsec.TunnelInterfaces.Tunnel.local_ip)
  
  return local_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelInterfaces_Tunnel::set_allocated_local_ip(::std::string* local_ip) {
  if (local_ip != NULL) {
    
  } else {
    
  }
  local_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_ip);
  // @@protoc_insertion_point(field_set_allocated:ipsec.TunnelInterfaces.Tunnel.local_ip)
}

// string remote_ip = 5;
inline void TunnelInterfaces_Tunnel::clear_remote_ip() {
  remote_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelInterfaces_Tunnel::remote_ip() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.remote_ip)
  return remote_ip_.GetNoArena();
}
inline void TunnelInterfaces_Tunnel::set_remote_ip(const ::std::string& value) {
  
  remote_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.remote_ip)
}
#if LANG_CXX11
inline void TunnelInterfaces_Tunnel::set_remote_ip(::std::string&& value) {
  
  remote_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.TunnelInterfaces.Tunnel.remote_ip)
}
#endif
inline void TunnelInterfaces_Tunnel::set_remote_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.TunnelInterfaces.Tunnel.remote_ip)
}
inline void TunnelInterfaces_Tunnel::set_remote_ip(const char* value, size_t size) {
  
  remote_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.TunnelInterfaces.Tunnel.remote_ip)
}
inline ::std::string* TunnelInterfaces_Tunnel::mutable_remote_ip() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.TunnelInterfaces.Tunnel.remote_ip)
  return remote_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelInterfaces_Tunnel::release_remote_ip() {
  // @@protoc_insertion_point(field_release:ipsec.TunnelInterfaces.Tunnel.remote_ip)
  
  return remote_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelInterfaces_Tunnel::set_allocated_remote_ip(::std::string* remote_ip) {
  if (remote_ip != NULL) {
    
  } else {
    
  }
  remote_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_ip);
  // @@protoc_insertion_point(field_set_allocated:ipsec.TunnelInterfaces.Tunnel.remote_ip)
}

// uint32 local_spi = 6;
inline void TunnelInterfaces_Tunnel::clear_local_spi() {
  local_spi_ = 0u;
}
inline ::google::protobuf::uint32 TunnelInterfaces_Tunnel::local_spi() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.local_spi)
  return local_spi_;
}
inline void TunnelInterfaces_Tunnel::set_local_spi(::google::protobuf::uint32 value) {
  
  local_spi_ = value;
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.local_spi)
}

// uint32 remote_spi = 7;
inline void TunnelInterfaces_Tunnel::clear_remote_spi() {
  remote_spi_ = 0u;
}
inline ::google::protobuf::uint32 TunnelInterfaces_Tunnel::remote_spi() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.remote_spi)
  return remote_spi_;
}
inline void TunnelInterfaces_Tunnel::set_remote_spi(::google::protobuf::uint32 value) {
  
  remote_spi_ = value;
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.remote_spi)
}

// .ipsec.CryptoAlgorithm crypto_alg = 8;
inline void TunnelInterfaces_Tunnel::clear_crypto_alg() {
  crypto_alg_ = 0;
}
inline ::ipsec::CryptoAlgorithm TunnelInterfaces_Tunnel::crypto_alg() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.crypto_alg)
  return static_cast< ::ipsec::CryptoAlgorithm >(crypto_alg_);
}
inline void TunnelInterfaces_Tunnel::set_crypto_alg(::ipsec::CryptoAlgorithm value) {
  
  crypto_alg_ = value;
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.crypto_alg)
}

// string local_crypto_key = 9;
inline void TunnelInterfaces_Tunnel::clear_local_crypto_key() {
  local_crypto_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelInterfaces_Tunnel::local_crypto_key() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.local_crypto_key)
  return local_crypto_key_.GetNoArena();
}
inline void TunnelInterfaces_Tunnel::set_local_crypto_key(const ::std::string& value) {
  
  local_crypto_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.local_crypto_key)
}
#if LANG_CXX11
inline void TunnelInterfaces_Tunnel::set_local_crypto_key(::std::string&& value) {
  
  local_crypto_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.TunnelInterfaces.Tunnel.local_crypto_key)
}
#endif
inline void TunnelInterfaces_Tunnel::set_local_crypto_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_crypto_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.TunnelInterfaces.Tunnel.local_crypto_key)
}
inline void TunnelInterfaces_Tunnel::set_local_crypto_key(const char* value, size_t size) {
  
  local_crypto_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.TunnelInterfaces.Tunnel.local_crypto_key)
}
inline ::std::string* TunnelInterfaces_Tunnel::mutable_local_crypto_key() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.TunnelInterfaces.Tunnel.local_crypto_key)
  return local_crypto_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelInterfaces_Tunnel::release_local_crypto_key() {
  // @@protoc_insertion_point(field_release:ipsec.TunnelInterfaces.Tunnel.local_crypto_key)
  
  return local_crypto_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelInterfaces_Tunnel::set_allocated_local_crypto_key(::std::string* local_crypto_key) {
  if (local_crypto_key != NULL) {
    
  } else {
    
  }
  local_crypto_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_crypto_key);
  // @@protoc_insertion_point(field_set_allocated:ipsec.TunnelInterfaces.Tunnel.local_crypto_key)
}

// string remote_crypto_key = 10;
inline void TunnelInterfaces_Tunnel::clear_remote_crypto_key() {
  remote_crypto_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelInterfaces_Tunnel::remote_crypto_key() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.remote_crypto_key)
  return remote_crypto_key_.GetNoArena();
}
inline void TunnelInterfaces_Tunnel::set_remote_crypto_key(const ::std::string& value) {
  
  remote_crypto_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.remote_crypto_key)
}
#if LANG_CXX11
inline void TunnelInterfaces_Tunnel::set_remote_crypto_key(::std::string&& value) {
  
  remote_crypto_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.TunnelInterfaces.Tunnel.remote_crypto_key)
}
#endif
inline void TunnelInterfaces_Tunnel::set_remote_crypto_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_crypto_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.TunnelInterfaces.Tunnel.remote_crypto_key)
}
inline void TunnelInterfaces_Tunnel::set_remote_crypto_key(const char* value, size_t size) {
  
  remote_crypto_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.TunnelInterfaces.Tunnel.remote_crypto_key)
}
inline ::std::string* TunnelInterfaces_Tunnel::mutable_remote_crypto_key() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.TunnelInterfaces.Tunnel.remote_crypto_key)
  return remote_crypto_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelInterfaces_Tunnel::release_remote_crypto_key() {
  // @@protoc_insertion_point(field_release:ipsec.TunnelInterfaces.Tunnel.remote_crypto_key)
  
  return remote_crypto_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelInterfaces_Tunnel::set_allocated_remote_crypto_key(::std::string* remote_crypto_key) {
  if (remote_crypto_key != NULL) {
    
  } else {
    
  }
  remote_crypto_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_crypto_key);
  // @@protoc_insertion_point(field_set_allocated:ipsec.TunnelInterfaces.Tunnel.remote_crypto_key)
}

// .ipsec.IntegAlgorithm integ_alg = 11;
inline void TunnelInterfaces_Tunnel::clear_integ_alg() {
  integ_alg_ = 0;
}
inline ::ipsec::IntegAlgorithm TunnelInterfaces_Tunnel::integ_alg() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.integ_alg)
  return static_cast< ::ipsec::IntegAlgorithm >(integ_alg_);
}
inline void TunnelInterfaces_Tunnel::set_integ_alg(::ipsec::IntegAlgorithm value) {
  
  integ_alg_ = value;
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.integ_alg)
}

// string local_integ_key = 12;
inline void TunnelInterfaces_Tunnel::clear_local_integ_key() {
  local_integ_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelInterfaces_Tunnel::local_integ_key() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.local_integ_key)
  return local_integ_key_.GetNoArena();
}
inline void TunnelInterfaces_Tunnel::set_local_integ_key(const ::std::string& value) {
  
  local_integ_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.local_integ_key)
}
#if LANG_CXX11
inline void TunnelInterfaces_Tunnel::set_local_integ_key(::std::string&& value) {
  
  local_integ_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.TunnelInterfaces.Tunnel.local_integ_key)
}
#endif
inline void TunnelInterfaces_Tunnel::set_local_integ_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_integ_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.TunnelInterfaces.Tunnel.local_integ_key)
}
inline void TunnelInterfaces_Tunnel::set_local_integ_key(const char* value, size_t size) {
  
  local_integ_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.TunnelInterfaces.Tunnel.local_integ_key)
}
inline ::std::string* TunnelInterfaces_Tunnel::mutable_local_integ_key() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.TunnelInterfaces.Tunnel.local_integ_key)
  return local_integ_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelInterfaces_Tunnel::release_local_integ_key() {
  // @@protoc_insertion_point(field_release:ipsec.TunnelInterfaces.Tunnel.local_integ_key)
  
  return local_integ_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelInterfaces_Tunnel::set_allocated_local_integ_key(::std::string* local_integ_key) {
  if (local_integ_key != NULL) {
    
  } else {
    
  }
  local_integ_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_integ_key);
  // @@protoc_insertion_point(field_set_allocated:ipsec.TunnelInterfaces.Tunnel.local_integ_key)
}

// string remote_integ_key = 13;
inline void TunnelInterfaces_Tunnel::clear_remote_integ_key() {
  remote_integ_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelInterfaces_Tunnel::remote_integ_key() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.remote_integ_key)
  return remote_integ_key_.GetNoArena();
}
inline void TunnelInterfaces_Tunnel::set_remote_integ_key(const ::std::string& value) {
  
  remote_integ_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.remote_integ_key)
}
#if LANG_CXX11
inline void TunnelInterfaces_Tunnel::set_remote_integ_key(::std::string&& value) {
  
  remote_integ_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.TunnelInterfaces.Tunnel.remote_integ_key)
}
#endif
inline void TunnelInterfaces_Tunnel::set_remote_integ_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_integ_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.TunnelInterfaces.Tunnel.remote_integ_key)
}
inline void TunnelInterfaces_Tunnel::set_remote_integ_key(const char* value, size_t size) {
  
  remote_integ_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.TunnelInterfaces.Tunnel.remote_integ_key)
}
inline ::std::string* TunnelInterfaces_Tunnel::mutable_remote_integ_key() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.TunnelInterfaces.Tunnel.remote_integ_key)
  return remote_integ_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelInterfaces_Tunnel::release_remote_integ_key() {
  // @@protoc_insertion_point(field_release:ipsec.TunnelInterfaces.Tunnel.remote_integ_key)
  
  return remote_integ_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelInterfaces_Tunnel::set_allocated_remote_integ_key(::std::string* remote_integ_key) {
  if (remote_integ_key != NULL) {
    
  } else {
    
  }
  remote_integ_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_integ_key);
  // @@protoc_insertion_point(field_set_allocated:ipsec.TunnelInterfaces.Tunnel.remote_integ_key)
}

// bool enabled = 100;
inline void TunnelInterfaces_Tunnel::clear_enabled() {
  enabled_ = false;
}
inline bool TunnelInterfaces_Tunnel::enabled() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.enabled)
  return enabled_;
}
inline void TunnelInterfaces_Tunnel::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.enabled)
}

// repeated string ip_addresses = 101;
inline int TunnelInterfaces_Tunnel::ip_addresses_size() const {
  return ip_addresses_.size();
}
inline void TunnelInterfaces_Tunnel::clear_ip_addresses() {
  ip_addresses_.Clear();
}
inline const ::std::string& TunnelInterfaces_Tunnel::ip_addresses(int index) const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.ip_addresses)
  return ip_addresses_.Get(index);
}
inline ::std::string* TunnelInterfaces_Tunnel::mutable_ip_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:ipsec.TunnelInterfaces.Tunnel.ip_addresses)
  return ip_addresses_.Mutable(index);
}
inline void TunnelInterfaces_Tunnel::set_ip_addresses(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.ip_addresses)
  ip_addresses_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TunnelInterfaces_Tunnel::set_ip_addresses(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.ip_addresses)
  ip_addresses_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TunnelInterfaces_Tunnel::set_ip_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ip_addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ipsec.TunnelInterfaces.Tunnel.ip_addresses)
}
inline void TunnelInterfaces_Tunnel::set_ip_addresses(int index, const char* value, size_t size) {
  ip_addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ipsec.TunnelInterfaces.Tunnel.ip_addresses)
}
inline ::std::string* TunnelInterfaces_Tunnel::add_ip_addresses() {
  // @@protoc_insertion_point(field_add_mutable:ipsec.TunnelInterfaces.Tunnel.ip_addresses)
  return ip_addresses_.Add();
}
inline void TunnelInterfaces_Tunnel::add_ip_addresses(const ::std::string& value) {
  ip_addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ipsec.TunnelInterfaces.Tunnel.ip_addresses)
}
#if LANG_CXX11
inline void TunnelInterfaces_Tunnel::add_ip_addresses(::std::string&& value) {
  ip_addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ipsec.TunnelInterfaces.Tunnel.ip_addresses)
}
#endif
inline void TunnelInterfaces_Tunnel::add_ip_addresses(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ip_addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ipsec.TunnelInterfaces.Tunnel.ip_addresses)
}
inline void TunnelInterfaces_Tunnel::add_ip_addresses(const char* value, size_t size) {
  ip_addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ipsec.TunnelInterfaces.Tunnel.ip_addresses)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TunnelInterfaces_Tunnel::ip_addresses() const {
  // @@protoc_insertion_point(field_list:ipsec.TunnelInterfaces.Tunnel.ip_addresses)
  return ip_addresses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TunnelInterfaces_Tunnel::mutable_ip_addresses() {
  // @@protoc_insertion_point(field_mutable_list:ipsec.TunnelInterfaces.Tunnel.ip_addresses)
  return &ip_addresses_;
}

// uint32 vrf = 102;
inline void TunnelInterfaces_Tunnel::clear_vrf() {
  vrf_ = 0u;
}
inline ::google::protobuf::uint32 TunnelInterfaces_Tunnel::vrf() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.vrf)
  return vrf_;
}
inline void TunnelInterfaces_Tunnel::set_vrf(::google::protobuf::uint32 value) {
  
  vrf_ = value;
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.vrf)
}

// string unnumbered_name = 103;
inline void TunnelInterfaces_Tunnel::clear_unnumbered_name() {
  unnumbered_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelInterfaces_Tunnel::unnumbered_name() const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.Tunnel.unnumbered_name)
  return unnumbered_name_.GetNoArena();
}
inline void TunnelInterfaces_Tunnel::set_unnumbered_name(const ::std::string& value) {
  
  unnumbered_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.TunnelInterfaces.Tunnel.unnumbered_name)
}
#if LANG_CXX11
inline void TunnelInterfaces_Tunnel::set_unnumbered_name(::std::string&& value) {
  
  unnumbered_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.TunnelInterfaces.Tunnel.unnumbered_name)
}
#endif
inline void TunnelInterfaces_Tunnel::set_unnumbered_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  unnumbered_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.TunnelInterfaces.Tunnel.unnumbered_name)
}
inline void TunnelInterfaces_Tunnel::set_unnumbered_name(const char* value, size_t size) {
  
  unnumbered_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.TunnelInterfaces.Tunnel.unnumbered_name)
}
inline ::std::string* TunnelInterfaces_Tunnel::mutable_unnumbered_name() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.TunnelInterfaces.Tunnel.unnumbered_name)
  return unnumbered_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelInterfaces_Tunnel::release_unnumbered_name() {
  // @@protoc_insertion_point(field_release:ipsec.TunnelInterfaces.Tunnel.unnumbered_name)
  
  return unnumbered_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelInterfaces_Tunnel::set_allocated_unnumbered_name(::std::string* unnumbered_name) {
  if (unnumbered_name != NULL) {
    
  } else {
    
  }
  unnumbered_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), unnumbered_name);
  // @@protoc_insertion_point(field_set_allocated:ipsec.TunnelInterfaces.Tunnel.unnumbered_name)
}

// -------------------------------------------------------------------

// TunnelInterfaces

// repeated .ipsec.TunnelInterfaces.Tunnel tunnels = 1;
inline int TunnelInterfaces::tunnels_size() const {
  return tunnels_.size();
}
inline void TunnelInterfaces::clear_tunnels() {
  tunnels_.Clear();
}
inline ::ipsec::TunnelInterfaces_Tunnel* TunnelInterfaces::mutable_tunnels(int index) {
  // @@protoc_insertion_point(field_mutable:ipsec.TunnelInterfaces.tunnels)
  return tunnels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ipsec::TunnelInterfaces_Tunnel >*
TunnelInterfaces::mutable_tunnels() {
  // @@protoc_insertion_point(field_mutable_list:ipsec.TunnelInterfaces.tunnels)
  return &tunnels_;
}
inline const ::ipsec::TunnelInterfaces_Tunnel& TunnelInterfaces::tunnels(int index) const {
  // @@protoc_insertion_point(field_get:ipsec.TunnelInterfaces.tunnels)
  return tunnels_.Get(index);
}
inline ::ipsec::TunnelInterfaces_Tunnel* TunnelInterfaces::add_tunnels() {
  // @@protoc_insertion_point(field_add:ipsec.TunnelInterfaces.tunnels)
  return tunnels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ipsec::TunnelInterfaces_Tunnel >&
TunnelInterfaces::tunnels() const {
  // @@protoc_insertion_point(field_list:ipsec.TunnelInterfaces.tunnels)
  return tunnels_;
}

// -------------------------------------------------------------------

// SecurityPolicyDatabases_SPD_Interface

// string name = 1;
inline void SecurityPolicyDatabases_SPD_Interface::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecurityPolicyDatabases_SPD_Interface::name() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.Interface.name)
  return name_.GetNoArena();
}
inline void SecurityPolicyDatabases_SPD_Interface::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.Interface.name)
}
#if LANG_CXX11
inline void SecurityPolicyDatabases_SPD_Interface::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.SecurityPolicyDatabases.SPD.Interface.name)
}
#endif
inline void SecurityPolicyDatabases_SPD_Interface::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.SecurityPolicyDatabases.SPD.Interface.name)
}
inline void SecurityPolicyDatabases_SPD_Interface::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.SecurityPolicyDatabases.SPD.Interface.name)
}
inline ::std::string* SecurityPolicyDatabases_SPD_Interface::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityPolicyDatabases.SPD.Interface.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityPolicyDatabases_SPD_Interface::release_name() {
  // @@protoc_insertion_point(field_release:ipsec.SecurityPolicyDatabases.SPD.Interface.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityPolicyDatabases_SPD_Interface::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ipsec.SecurityPolicyDatabases.SPD.Interface.name)
}

// -------------------------------------------------------------------

// SecurityPolicyDatabases_SPD_PolicyEntry

// string sa = 1;
inline void SecurityPolicyDatabases_SPD_PolicyEntry::clear_sa() {
  sa_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecurityPolicyDatabases_SPD_PolicyEntry::sa() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.sa)
  return sa_.GetNoArena();
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_sa(const ::std::string& value) {
  
  sa_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.sa)
}
#if LANG_CXX11
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_sa(::std::string&& value) {
  
  sa_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.sa)
}
#endif
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_sa(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sa_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.sa)
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_sa(const char* value, size_t size) {
  
  sa_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.sa)
}
inline ::std::string* SecurityPolicyDatabases_SPD_PolicyEntry::mutable_sa() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.sa)
  return sa_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityPolicyDatabases_SPD_PolicyEntry::release_sa() {
  // @@protoc_insertion_point(field_release:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.sa)
  
  return sa_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_allocated_sa(::std::string* sa) {
  if (sa != NULL) {
    
  } else {
    
  }
  sa_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sa);
  // @@protoc_insertion_point(field_set_allocated:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.sa)
}

// int32 priority = 2;
inline void SecurityPolicyDatabases_SPD_PolicyEntry::clear_priority() {
  priority_ = 0;
}
inline ::google::protobuf::int32 SecurityPolicyDatabases_SPD_PolicyEntry::priority() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.priority)
  return priority_;
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_priority(::google::protobuf::int32 value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.priority)
}

// bool is_outbound = 3;
inline void SecurityPolicyDatabases_SPD_PolicyEntry::clear_is_outbound() {
  is_outbound_ = false;
}
inline bool SecurityPolicyDatabases_SPD_PolicyEntry::is_outbound() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.is_outbound)
  return is_outbound_;
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_is_outbound(bool value) {
  
  is_outbound_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.is_outbound)
}

// string remote_addr_start = 4;
inline void SecurityPolicyDatabases_SPD_PolicyEntry::clear_remote_addr_start() {
  remote_addr_start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecurityPolicyDatabases_SPD_PolicyEntry::remote_addr_start() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_start)
  return remote_addr_start_.GetNoArena();
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_remote_addr_start(const ::std::string& value) {
  
  remote_addr_start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_start)
}
#if LANG_CXX11
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_remote_addr_start(::std::string&& value) {
  
  remote_addr_start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_start)
}
#endif
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_remote_addr_start(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_addr_start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_start)
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_remote_addr_start(const char* value, size_t size) {
  
  remote_addr_start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_start)
}
inline ::std::string* SecurityPolicyDatabases_SPD_PolicyEntry::mutable_remote_addr_start() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_start)
  return remote_addr_start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityPolicyDatabases_SPD_PolicyEntry::release_remote_addr_start() {
  // @@protoc_insertion_point(field_release:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_start)
  
  return remote_addr_start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_allocated_remote_addr_start(::std::string* remote_addr_start) {
  if (remote_addr_start != NULL) {
    
  } else {
    
  }
  remote_addr_start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_addr_start);
  // @@protoc_insertion_point(field_set_allocated:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_start)
}

// string remote_addr_stop = 5;
inline void SecurityPolicyDatabases_SPD_PolicyEntry::clear_remote_addr_stop() {
  remote_addr_stop_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecurityPolicyDatabases_SPD_PolicyEntry::remote_addr_stop() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_stop)
  return remote_addr_stop_.GetNoArena();
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_remote_addr_stop(const ::std::string& value) {
  
  remote_addr_stop_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_stop)
}
#if LANG_CXX11
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_remote_addr_stop(::std::string&& value) {
  
  remote_addr_stop_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_stop)
}
#endif
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_remote_addr_stop(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_addr_stop_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_stop)
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_remote_addr_stop(const char* value, size_t size) {
  
  remote_addr_stop_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_stop)
}
inline ::std::string* SecurityPolicyDatabases_SPD_PolicyEntry::mutable_remote_addr_stop() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_stop)
  return remote_addr_stop_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityPolicyDatabases_SPD_PolicyEntry::release_remote_addr_stop() {
  // @@protoc_insertion_point(field_release:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_stop)
  
  return remote_addr_stop_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_allocated_remote_addr_stop(::std::string* remote_addr_stop) {
  if (remote_addr_stop != NULL) {
    
  } else {
    
  }
  remote_addr_stop_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_addr_stop);
  // @@protoc_insertion_point(field_set_allocated:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_addr_stop)
}

// string local_addr_start = 6;
inline void SecurityPolicyDatabases_SPD_PolicyEntry::clear_local_addr_start() {
  local_addr_start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecurityPolicyDatabases_SPD_PolicyEntry::local_addr_start() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_start)
  return local_addr_start_.GetNoArena();
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_local_addr_start(const ::std::string& value) {
  
  local_addr_start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_start)
}
#if LANG_CXX11
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_local_addr_start(::std::string&& value) {
  
  local_addr_start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_start)
}
#endif
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_local_addr_start(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_addr_start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_start)
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_local_addr_start(const char* value, size_t size) {
  
  local_addr_start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_start)
}
inline ::std::string* SecurityPolicyDatabases_SPD_PolicyEntry::mutable_local_addr_start() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_start)
  return local_addr_start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityPolicyDatabases_SPD_PolicyEntry::release_local_addr_start() {
  // @@protoc_insertion_point(field_release:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_start)
  
  return local_addr_start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_allocated_local_addr_start(::std::string* local_addr_start) {
  if (local_addr_start != NULL) {
    
  } else {
    
  }
  local_addr_start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_addr_start);
  // @@protoc_insertion_point(field_set_allocated:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_start)
}

// string local_addr_stop = 7;
inline void SecurityPolicyDatabases_SPD_PolicyEntry::clear_local_addr_stop() {
  local_addr_stop_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecurityPolicyDatabases_SPD_PolicyEntry::local_addr_stop() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_stop)
  return local_addr_stop_.GetNoArena();
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_local_addr_stop(const ::std::string& value) {
  
  local_addr_stop_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_stop)
}
#if LANG_CXX11
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_local_addr_stop(::std::string&& value) {
  
  local_addr_stop_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_stop)
}
#endif
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_local_addr_stop(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_addr_stop_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_stop)
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_local_addr_stop(const char* value, size_t size) {
  
  local_addr_stop_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_stop)
}
inline ::std::string* SecurityPolicyDatabases_SPD_PolicyEntry::mutable_local_addr_stop() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_stop)
  return local_addr_stop_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityPolicyDatabases_SPD_PolicyEntry::release_local_addr_stop() {
  // @@protoc_insertion_point(field_release:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_stop)
  
  return local_addr_stop_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_allocated_local_addr_stop(::std::string* local_addr_stop) {
  if (local_addr_stop != NULL) {
    
  } else {
    
  }
  local_addr_stop_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_addr_stop);
  // @@protoc_insertion_point(field_set_allocated:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_addr_stop)
}

// uint32 protocol = 8;
inline void SecurityPolicyDatabases_SPD_PolicyEntry::clear_protocol() {
  protocol_ = 0u;
}
inline ::google::protobuf::uint32 SecurityPolicyDatabases_SPD_PolicyEntry::protocol() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.protocol)
  return protocol_;
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_protocol(::google::protobuf::uint32 value) {
  
  protocol_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.protocol)
}

// uint32 remote_port_start = 9;
inline void SecurityPolicyDatabases_SPD_PolicyEntry::clear_remote_port_start() {
  remote_port_start_ = 0u;
}
inline ::google::protobuf::uint32 SecurityPolicyDatabases_SPD_PolicyEntry::remote_port_start() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_port_start)
  return remote_port_start_;
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_remote_port_start(::google::protobuf::uint32 value) {
  
  remote_port_start_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_port_start)
}

// uint32 remote_port_stop = 10;
inline void SecurityPolicyDatabases_SPD_PolicyEntry::clear_remote_port_stop() {
  remote_port_stop_ = 0u;
}
inline ::google::protobuf::uint32 SecurityPolicyDatabases_SPD_PolicyEntry::remote_port_stop() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_port_stop)
  return remote_port_stop_;
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_remote_port_stop(::google::protobuf::uint32 value) {
  
  remote_port_stop_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.remote_port_stop)
}

// uint32 local_port_start = 11;
inline void SecurityPolicyDatabases_SPD_PolicyEntry::clear_local_port_start() {
  local_port_start_ = 0u;
}
inline ::google::protobuf::uint32 SecurityPolicyDatabases_SPD_PolicyEntry::local_port_start() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_port_start)
  return local_port_start_;
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_local_port_start(::google::protobuf::uint32 value) {
  
  local_port_start_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_port_start)
}

// uint32 local_port_stop = 12;
inline void SecurityPolicyDatabases_SPD_PolicyEntry::clear_local_port_stop() {
  local_port_stop_ = 0u;
}
inline ::google::protobuf::uint32 SecurityPolicyDatabases_SPD_PolicyEntry::local_port_stop() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_port_stop)
  return local_port_stop_;
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_local_port_stop(::google::protobuf::uint32 value) {
  
  local_port_stop_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.local_port_stop)
}

// .ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.Action action = 13;
inline void SecurityPolicyDatabases_SPD_PolicyEntry::clear_action() {
  action_ = 0;
}
inline ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry_Action SecurityPolicyDatabases_SPD_PolicyEntry::action() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.action)
  return static_cast< ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry_Action >(action_);
}
inline void SecurityPolicyDatabases_SPD_PolicyEntry::set_action(::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry_Action value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.PolicyEntry.action)
}

// -------------------------------------------------------------------

// SecurityPolicyDatabases_SPD

// string name = 1;
inline void SecurityPolicyDatabases_SPD::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecurityPolicyDatabases_SPD::name() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.name)
  return name_.GetNoArena();
}
inline void SecurityPolicyDatabases_SPD::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.SecurityPolicyDatabases.SPD.name)
}
#if LANG_CXX11
inline void SecurityPolicyDatabases_SPD::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.SecurityPolicyDatabases.SPD.name)
}
#endif
inline void SecurityPolicyDatabases_SPD::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.SecurityPolicyDatabases.SPD.name)
}
inline void SecurityPolicyDatabases_SPD::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.SecurityPolicyDatabases.SPD.name)
}
inline ::std::string* SecurityPolicyDatabases_SPD::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityPolicyDatabases.SPD.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityPolicyDatabases_SPD::release_name() {
  // @@protoc_insertion_point(field_release:ipsec.SecurityPolicyDatabases.SPD.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityPolicyDatabases_SPD::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ipsec.SecurityPolicyDatabases.SPD.name)
}

// repeated .ipsec.SecurityPolicyDatabases.SPD.Interface interfaces = 2;
inline int SecurityPolicyDatabases_SPD::interfaces_size() const {
  return interfaces_.size();
}
inline void SecurityPolicyDatabases_SPD::clear_interfaces() {
  interfaces_.Clear();
}
inline ::ipsec::SecurityPolicyDatabases_SPD_Interface* SecurityPolicyDatabases_SPD::mutable_interfaces(int index) {
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityPolicyDatabases.SPD.interfaces)
  return interfaces_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD_Interface >*
SecurityPolicyDatabases_SPD::mutable_interfaces() {
  // @@protoc_insertion_point(field_mutable_list:ipsec.SecurityPolicyDatabases.SPD.interfaces)
  return &interfaces_;
}
inline const ::ipsec::SecurityPolicyDatabases_SPD_Interface& SecurityPolicyDatabases_SPD::interfaces(int index) const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.interfaces)
  return interfaces_.Get(index);
}
inline ::ipsec::SecurityPolicyDatabases_SPD_Interface* SecurityPolicyDatabases_SPD::add_interfaces() {
  // @@protoc_insertion_point(field_add:ipsec.SecurityPolicyDatabases.SPD.interfaces)
  return interfaces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD_Interface >&
SecurityPolicyDatabases_SPD::interfaces() const {
  // @@protoc_insertion_point(field_list:ipsec.SecurityPolicyDatabases.SPD.interfaces)
  return interfaces_;
}

// repeated .ipsec.SecurityPolicyDatabases.SPD.PolicyEntry policy_entries = 3;
inline int SecurityPolicyDatabases_SPD::policy_entries_size() const {
  return policy_entries_.size();
}
inline void SecurityPolicyDatabases_SPD::clear_policy_entries() {
  policy_entries_.Clear();
}
inline ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry* SecurityPolicyDatabases_SPD::mutable_policy_entries(int index) {
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityPolicyDatabases.SPD.policy_entries)
  return policy_entries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry >*
SecurityPolicyDatabases_SPD::mutable_policy_entries() {
  // @@protoc_insertion_point(field_mutable_list:ipsec.SecurityPolicyDatabases.SPD.policy_entries)
  return &policy_entries_;
}
inline const ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry& SecurityPolicyDatabases_SPD::policy_entries(int index) const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.SPD.policy_entries)
  return policy_entries_.Get(index);
}
inline ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry* SecurityPolicyDatabases_SPD::add_policy_entries() {
  // @@protoc_insertion_point(field_add:ipsec.SecurityPolicyDatabases.SPD.policy_entries)
  return policy_entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry >&
SecurityPolicyDatabases_SPD::policy_entries() const {
  // @@protoc_insertion_point(field_list:ipsec.SecurityPolicyDatabases.SPD.policy_entries)
  return policy_entries_;
}

// -------------------------------------------------------------------

// SecurityPolicyDatabases

// repeated .ipsec.SecurityPolicyDatabases.SPD spds = 1;
inline int SecurityPolicyDatabases::spds_size() const {
  return spds_.size();
}
inline void SecurityPolicyDatabases::clear_spds() {
  spds_.Clear();
}
inline ::ipsec::SecurityPolicyDatabases_SPD* SecurityPolicyDatabases::mutable_spds(int index) {
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityPolicyDatabases.spds)
  return spds_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD >*
SecurityPolicyDatabases::mutable_spds() {
  // @@protoc_insertion_point(field_mutable_list:ipsec.SecurityPolicyDatabases.spds)
  return &spds_;
}
inline const ::ipsec::SecurityPolicyDatabases_SPD& SecurityPolicyDatabases::spds(int index) const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityPolicyDatabases.spds)
  return spds_.Get(index);
}
inline ::ipsec::SecurityPolicyDatabases_SPD* SecurityPolicyDatabases::add_spds() {
  // @@protoc_insertion_point(field_add:ipsec.SecurityPolicyDatabases.spds)
  return spds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD >&
SecurityPolicyDatabases::spds() const {
  // @@protoc_insertion_point(field_list:ipsec.SecurityPolicyDatabases.spds)
  return spds_;
}

// -------------------------------------------------------------------

// SecurityAssociations_SA

// string name = 1;
inline void SecurityAssociations_SA::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecurityAssociations_SA::name() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityAssociations.SA.name)
  return name_.GetNoArena();
}
inline void SecurityAssociations_SA::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.SecurityAssociations.SA.name)
}
#if LANG_CXX11
inline void SecurityAssociations_SA::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.SecurityAssociations.SA.name)
}
#endif
inline void SecurityAssociations_SA::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.SecurityAssociations.SA.name)
}
inline void SecurityAssociations_SA::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.SecurityAssociations.SA.name)
}
inline ::std::string* SecurityAssociations_SA::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityAssociations.SA.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityAssociations_SA::release_name() {
  // @@protoc_insertion_point(field_release:ipsec.SecurityAssociations.SA.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityAssociations_SA::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ipsec.SecurityAssociations.SA.name)
}

// uint32 spi = 2;
inline void SecurityAssociations_SA::clear_spi() {
  spi_ = 0u;
}
inline ::google::protobuf::uint32 SecurityAssociations_SA::spi() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityAssociations.SA.spi)
  return spi_;
}
inline void SecurityAssociations_SA::set_spi(::google::protobuf::uint32 value) {
  
  spi_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityAssociations.SA.spi)
}

// .ipsec.SecurityAssociations.SA.IPSecProtocol protocol = 3;
inline void SecurityAssociations_SA::clear_protocol() {
  protocol_ = 0;
}
inline ::ipsec::SecurityAssociations_SA_IPSecProtocol SecurityAssociations_SA::protocol() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityAssociations.SA.protocol)
  return static_cast< ::ipsec::SecurityAssociations_SA_IPSecProtocol >(protocol_);
}
inline void SecurityAssociations_SA::set_protocol(::ipsec::SecurityAssociations_SA_IPSecProtocol value) {
  
  protocol_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityAssociations.SA.protocol)
}

// .ipsec.CryptoAlgorithm crypto_alg = 4;
inline void SecurityAssociations_SA::clear_crypto_alg() {
  crypto_alg_ = 0;
}
inline ::ipsec::CryptoAlgorithm SecurityAssociations_SA::crypto_alg() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityAssociations.SA.crypto_alg)
  return static_cast< ::ipsec::CryptoAlgorithm >(crypto_alg_);
}
inline void SecurityAssociations_SA::set_crypto_alg(::ipsec::CryptoAlgorithm value) {
  
  crypto_alg_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityAssociations.SA.crypto_alg)
}

// string crypto_key = 5;
inline void SecurityAssociations_SA::clear_crypto_key() {
  crypto_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecurityAssociations_SA::crypto_key() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityAssociations.SA.crypto_key)
  return crypto_key_.GetNoArena();
}
inline void SecurityAssociations_SA::set_crypto_key(const ::std::string& value) {
  
  crypto_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.SecurityAssociations.SA.crypto_key)
}
#if LANG_CXX11
inline void SecurityAssociations_SA::set_crypto_key(::std::string&& value) {
  
  crypto_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.SecurityAssociations.SA.crypto_key)
}
#endif
inline void SecurityAssociations_SA::set_crypto_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  crypto_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.SecurityAssociations.SA.crypto_key)
}
inline void SecurityAssociations_SA::set_crypto_key(const char* value, size_t size) {
  
  crypto_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.SecurityAssociations.SA.crypto_key)
}
inline ::std::string* SecurityAssociations_SA::mutable_crypto_key() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityAssociations.SA.crypto_key)
  return crypto_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityAssociations_SA::release_crypto_key() {
  // @@protoc_insertion_point(field_release:ipsec.SecurityAssociations.SA.crypto_key)
  
  return crypto_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityAssociations_SA::set_allocated_crypto_key(::std::string* crypto_key) {
  if (crypto_key != NULL) {
    
  } else {
    
  }
  crypto_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), crypto_key);
  // @@protoc_insertion_point(field_set_allocated:ipsec.SecurityAssociations.SA.crypto_key)
}

// .ipsec.IntegAlgorithm integ_alg = 6;
inline void SecurityAssociations_SA::clear_integ_alg() {
  integ_alg_ = 0;
}
inline ::ipsec::IntegAlgorithm SecurityAssociations_SA::integ_alg() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityAssociations.SA.integ_alg)
  return static_cast< ::ipsec::IntegAlgorithm >(integ_alg_);
}
inline void SecurityAssociations_SA::set_integ_alg(::ipsec::IntegAlgorithm value) {
  
  integ_alg_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityAssociations.SA.integ_alg)
}

// string integ_key = 7;
inline void SecurityAssociations_SA::clear_integ_key() {
  integ_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecurityAssociations_SA::integ_key() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityAssociations.SA.integ_key)
  return integ_key_.GetNoArena();
}
inline void SecurityAssociations_SA::set_integ_key(const ::std::string& value) {
  
  integ_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.SecurityAssociations.SA.integ_key)
}
#if LANG_CXX11
inline void SecurityAssociations_SA::set_integ_key(::std::string&& value) {
  
  integ_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.SecurityAssociations.SA.integ_key)
}
#endif
inline void SecurityAssociations_SA::set_integ_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  integ_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.SecurityAssociations.SA.integ_key)
}
inline void SecurityAssociations_SA::set_integ_key(const char* value, size_t size) {
  
  integ_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.SecurityAssociations.SA.integ_key)
}
inline ::std::string* SecurityAssociations_SA::mutable_integ_key() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityAssociations.SA.integ_key)
  return integ_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityAssociations_SA::release_integ_key() {
  // @@protoc_insertion_point(field_release:ipsec.SecurityAssociations.SA.integ_key)
  
  return integ_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityAssociations_SA::set_allocated_integ_key(::std::string* integ_key) {
  if (integ_key != NULL) {
    
  } else {
    
  }
  integ_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), integ_key);
  // @@protoc_insertion_point(field_set_allocated:ipsec.SecurityAssociations.SA.integ_key)
}

// bool use_esn = 8;
inline void SecurityAssociations_SA::clear_use_esn() {
  use_esn_ = false;
}
inline bool SecurityAssociations_SA::use_esn() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityAssociations.SA.use_esn)
  return use_esn_;
}
inline void SecurityAssociations_SA::set_use_esn(bool value) {
  
  use_esn_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityAssociations.SA.use_esn)
}

// bool use_anti_replay = 9;
inline void SecurityAssociations_SA::clear_use_anti_replay() {
  use_anti_replay_ = false;
}
inline bool SecurityAssociations_SA::use_anti_replay() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityAssociations.SA.use_anti_replay)
  return use_anti_replay_;
}
inline void SecurityAssociations_SA::set_use_anti_replay(bool value) {
  
  use_anti_replay_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityAssociations.SA.use_anti_replay)
}

// string tunnel_src_addr = 10;
inline void SecurityAssociations_SA::clear_tunnel_src_addr() {
  tunnel_src_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecurityAssociations_SA::tunnel_src_addr() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityAssociations.SA.tunnel_src_addr)
  return tunnel_src_addr_.GetNoArena();
}
inline void SecurityAssociations_SA::set_tunnel_src_addr(const ::std::string& value) {
  
  tunnel_src_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.SecurityAssociations.SA.tunnel_src_addr)
}
#if LANG_CXX11
inline void SecurityAssociations_SA::set_tunnel_src_addr(::std::string&& value) {
  
  tunnel_src_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.SecurityAssociations.SA.tunnel_src_addr)
}
#endif
inline void SecurityAssociations_SA::set_tunnel_src_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tunnel_src_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.SecurityAssociations.SA.tunnel_src_addr)
}
inline void SecurityAssociations_SA::set_tunnel_src_addr(const char* value, size_t size) {
  
  tunnel_src_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.SecurityAssociations.SA.tunnel_src_addr)
}
inline ::std::string* SecurityAssociations_SA::mutable_tunnel_src_addr() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityAssociations.SA.tunnel_src_addr)
  return tunnel_src_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityAssociations_SA::release_tunnel_src_addr() {
  // @@protoc_insertion_point(field_release:ipsec.SecurityAssociations.SA.tunnel_src_addr)
  
  return tunnel_src_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityAssociations_SA::set_allocated_tunnel_src_addr(::std::string* tunnel_src_addr) {
  if (tunnel_src_addr != NULL) {
    
  } else {
    
  }
  tunnel_src_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tunnel_src_addr);
  // @@protoc_insertion_point(field_set_allocated:ipsec.SecurityAssociations.SA.tunnel_src_addr)
}

// string tunnel_dst_addr = 11;
inline void SecurityAssociations_SA::clear_tunnel_dst_addr() {
  tunnel_dst_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecurityAssociations_SA::tunnel_dst_addr() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityAssociations.SA.tunnel_dst_addr)
  return tunnel_dst_addr_.GetNoArena();
}
inline void SecurityAssociations_SA::set_tunnel_dst_addr(const ::std::string& value) {
  
  tunnel_dst_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipsec.SecurityAssociations.SA.tunnel_dst_addr)
}
#if LANG_CXX11
inline void SecurityAssociations_SA::set_tunnel_dst_addr(::std::string&& value) {
  
  tunnel_dst_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipsec.SecurityAssociations.SA.tunnel_dst_addr)
}
#endif
inline void SecurityAssociations_SA::set_tunnel_dst_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tunnel_dst_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipsec.SecurityAssociations.SA.tunnel_dst_addr)
}
inline void SecurityAssociations_SA::set_tunnel_dst_addr(const char* value, size_t size) {
  
  tunnel_dst_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipsec.SecurityAssociations.SA.tunnel_dst_addr)
}
inline ::std::string* SecurityAssociations_SA::mutable_tunnel_dst_addr() {
  
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityAssociations.SA.tunnel_dst_addr)
  return tunnel_dst_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityAssociations_SA::release_tunnel_dst_addr() {
  // @@protoc_insertion_point(field_release:ipsec.SecurityAssociations.SA.tunnel_dst_addr)
  
  return tunnel_dst_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityAssociations_SA::set_allocated_tunnel_dst_addr(::std::string* tunnel_dst_addr) {
  if (tunnel_dst_addr != NULL) {
    
  } else {
    
  }
  tunnel_dst_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tunnel_dst_addr);
  // @@protoc_insertion_point(field_set_allocated:ipsec.SecurityAssociations.SA.tunnel_dst_addr)
}

// bool enable_udp_encap = 12;
inline void SecurityAssociations_SA::clear_enable_udp_encap() {
  enable_udp_encap_ = false;
}
inline bool SecurityAssociations_SA::enable_udp_encap() const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityAssociations.SA.enable_udp_encap)
  return enable_udp_encap_;
}
inline void SecurityAssociations_SA::set_enable_udp_encap(bool value) {
  
  enable_udp_encap_ = value;
  // @@protoc_insertion_point(field_set:ipsec.SecurityAssociations.SA.enable_udp_encap)
}

// -------------------------------------------------------------------

// SecurityAssociations

// repeated .ipsec.SecurityAssociations.SA sas = 1;
inline int SecurityAssociations::sas_size() const {
  return sas_.size();
}
inline void SecurityAssociations::clear_sas() {
  sas_.Clear();
}
inline ::ipsec::SecurityAssociations_SA* SecurityAssociations::mutable_sas(int index) {
  // @@protoc_insertion_point(field_mutable:ipsec.SecurityAssociations.sas)
  return sas_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityAssociations_SA >*
SecurityAssociations::mutable_sas() {
  // @@protoc_insertion_point(field_mutable_list:ipsec.SecurityAssociations.sas)
  return &sas_;
}
inline const ::ipsec::SecurityAssociations_SA& SecurityAssociations::sas(int index) const {
  // @@protoc_insertion_point(field_get:ipsec.SecurityAssociations.sas)
  return sas_.Get(index);
}
inline ::ipsec::SecurityAssociations_SA* SecurityAssociations::add_sas() {
  // @@protoc_insertion_point(field_add:ipsec.SecurityAssociations.sas)
  return sas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityAssociations_SA >&
SecurityAssociations::sas() const {
  // @@protoc_insertion_point(field_list:ipsec.SecurityAssociations.sas)
  return sas_;
}

// -------------------------------------------------------------------

// ResyncRequest

// repeated .ipsec.TunnelInterfaces.Tunnel tunnels = 1;
inline int ResyncRequest::tunnels_size() const {
  return tunnels_.size();
}
inline void ResyncRequest::clear_tunnels() {
  tunnels_.Clear();
}
inline ::ipsec::TunnelInterfaces_Tunnel* ResyncRequest::mutable_tunnels(int index) {
  // @@protoc_insertion_point(field_mutable:ipsec.ResyncRequest.tunnels)
  return tunnels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ipsec::TunnelInterfaces_Tunnel >*
ResyncRequest::mutable_tunnels() {
  // @@protoc_insertion_point(field_mutable_list:ipsec.ResyncRequest.tunnels)
  return &tunnels_;
}
inline const ::ipsec::TunnelInterfaces_Tunnel& ResyncRequest::tunnels(int index) const {
  // @@protoc_insertion_point(field_get:ipsec.ResyncRequest.tunnels)
  return tunnels_.Get(index);
}
inline ::ipsec::TunnelInterfaces_Tunnel* ResyncRequest::add_tunnels() {
  // @@protoc_insertion_point(field_add:ipsec.ResyncRequest.tunnels)
  return tunnels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ipsec::TunnelInterfaces_Tunnel >&
ResyncRequest::tunnels() const {
  // @@protoc_insertion_point(field_list:ipsec.ResyncRequest.tunnels)
  return tunnels_;
}

// repeated .ipsec.SecurityPolicyDatabases.SPD spds = 2;
inline int ResyncRequest::spds_size() const {
  return spds_.size();
}
inline void ResyncRequest::clear_spds() {
  spds_.Clear();
}
inline ::ipsec::SecurityPolicyDatabases_SPD* ResyncRequest::mutable_spds(int index) {
  // @@protoc_insertion_point(field_mutable:ipsec.ResyncRequest.spds)
  return spds_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD >*
ResyncRequest::mutable_spds() {
  // @@protoc_insertion_point(field_mutable_list:ipsec.ResyncRequest.spds)
  return &spds_;
}
inline const ::ipsec::SecurityPolicyDatabases_SPD& ResyncRequest::spds(int index) const {
  // @@protoc_insertion_point(field_get:ipsec.ResyncRequest.spds)
  return spds_.Get(index);
}
inline ::ipsec::SecurityPolicyDatabases_SPD* ResyncRequest::add_spds() {
  // @@protoc_insertion_point(field_add:ipsec.ResyncRequest.spds)
  return spds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityPolicyDatabases_SPD >&
ResyncRequest::spds() const {
  // @@protoc_insertion_point(field_list:ipsec.ResyncRequest.spds)
  return spds_;
}

// repeated .ipsec.SecurityAssociations.SA sas = 3;
inline int ResyncRequest::sas_size() const {
  return sas_.size();
}
inline void ResyncRequest::clear_sas() {
  sas_.Clear();
}
inline ::ipsec::SecurityAssociations_SA* ResyncRequest::mutable_sas(int index) {
  // @@protoc_insertion_point(field_mutable:ipsec.ResyncRequest.sas)
  return sas_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityAssociations_SA >*
ResyncRequest::mutable_sas() {
  // @@protoc_insertion_point(field_mutable_list:ipsec.ResyncRequest.sas)
  return &sas_;
}
inline const ::ipsec::SecurityAssociations_SA& ResyncRequest::sas(int index) const {
  // @@protoc_insertion_point(field_get:ipsec.ResyncRequest.sas)
  return sas_.Get(index);
}
inline ::ipsec::SecurityAssociations_SA* ResyncRequest::add_sas() {
  // @@protoc_insertion_point(field_add:ipsec.ResyncRequest.sas)
  return sas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ipsec::SecurityAssociations_SA >&
ResyncRequest::sas() const {
  // @@protoc_insertion_point(field_list:ipsec.ResyncRequest.sas)
  return sas_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ipsec

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry_Action>() {
  return ::ipsec::SecurityPolicyDatabases_SPD_PolicyEntry_Action_descriptor();
}
template <> struct is_proto_enum< ::ipsec::SecurityAssociations_SA_IPSecProtocol> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ipsec::SecurityAssociations_SA_IPSecProtocol>() {
  return ::ipsec::SecurityAssociations_SA_IPSecProtocol_descriptor();
}
template <> struct is_proto_enum< ::ipsec::CryptoAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ipsec::CryptoAlgorithm>() {
  return ::ipsec::CryptoAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::ipsec::IntegAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ipsec::IntegAlgorithm>() {
  return ::ipsec::IntegAlgorithm_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_vpp_2fmodel_2fipsec_2fipsec_2eproto
